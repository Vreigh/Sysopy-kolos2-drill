Potoki nienazwane::Potoki nienazwane:
>>>a)moga byc stosowane tylko przez procesy majace wspolnego przodka 
>>>b)sluza do komunikacji miedzy procesami 
c)moga byc tworzone funkcja int mkfifo(const char *name, mode_t mode) 
d)maja swoje dowiazanie z systemie plikow i moga byc identyfikowane przez nazwe 
e)sa zawsze laczami dwukierunkowymi 
f)istnieja tylko do czasu ich zamkniecia przez wszystkie procesy ich uzywajace 

Potoki nienazwane::Potok nienazwany mozna utworzyc funkcja:
a)int mkfifo(const char *name, mode_t mode) 
>>> b)FILE * popen (const char *command, const char *mode) 
>>>c)int pipe(int filedes[2]) 
d)int open (const char *name, int flags) 
e)int fork() 
f)ssize_t read(int fd, void *buf, size_t count) 

Potoki nazwane::Wywolanie funkcji: fcntl(fds, F_SETFL, O_NONBLOCK), gdzie fds to tablica deskryptorow zwiazana z potokiem nienazwanym, spowoduje, ze: 
>>>a)jezeli wywolamy funkcje write, a konce do odczytu potoku opisywanego przez fds zostaly zamkniete, to zostanie wygenerowany sygnal SIGPIPE 
b)w przypadku proby odczytu z pustego potoku read zostanie zablokowane 
c)w przypadku proby zapisu do pelnego potoku write zostanie zablokowane 
>>>d)w przypadku proby zapisu do pelnego potoku write zwroci -1 
>>>e)w przypadku proby zapisu do pelnego potoku write ustawi wartosc errno na EAGAIN 
>>>f)w przypadku proby odczytu z pustego potoku read ustawi wartosc errno na EAGAIN 

Lacza strumieniowe::Wybierz prawdziwe zdania dotyczace laczy strumieniowych.
>>>a)Pojedynczy proces moze uzywac tego samego deskryptora do zapisu i odczytu z lacza strumieniowego. 
>>>b)Lacza strumieniowe maja ograniczona pojemnosc 
>>>c)Lacza strumieniowe sa potokami nienazwanymi 
d)Lacza strumieniowe sa obslugiwane przez wszystkie systemy uniksowe 
e)Lacza strumieniowe moga byc tworzone funkcja int mkfifo(const char *name, mode_t mode) 
f)Lacza strumieniowe sa laczami jednokierunkowymi 

Potoki nienazwane::Jezeli wywolamy funkcje write dla lacza, ktorego konce do odczytu zostaly zamkniete, to zostanie wygenerowany sygnal:
>>>a)SIGPIPE 
b)SIGINT 
c)SIGSEGV 
e)SIGTRAP 
d)SIGKILL 
f)SIGUSR1 

Synchronizacja::Ktore problemy moga sie przytrafic w wielowatkowych progamach dzialajacych bez synchronizacji?
>>>a) zaglodzenie
>>>b) wykluczenie
>>>c) spojnosci danych
>>>d) zawieszenie
e) restart programu


Mutex::Mechanizm muteksow:
>>>a) umozliwia synchronizacje blokow kodu
b) umozliwia wykonywanie synchronizowanych blokow kodu przez wiele watkow jednoczesnie
c) wyklucza mozliwosc zakleszczenia programu
>>>d) moze wspolpracowac ze zmiennymi warunkow (Condition Variables)
e) znajduje sie w bibliotece conditionvariables.h


Blokady ReaderWriter::Blokady ReaderWriter:
>>>a) sa mechaniznem synchronizacji blokow kodu
>>>b) reprezentuje struktura pthread_rwlock_t
>>>c) umozliwiaja prace w trybie tylko do odczytu w synchronizowanych blokach kodu przez wiele watkow
d) umozliwiaja prace w trybie do zapisu w synchronizowanych blokach kodu przez wiele watkow
e) nie moga stanowic rozwiazania problemu spojnosci danych

::Zmienne Warunkowe::Zmienne warunkowe:
a) posiadaja implementacje w <pthread.h>
>>>b) oferuja mechanizm okreslania maskymalnego czasu oczekiwania przez watek
>>>c) moga zostac uzyte w polaczeniu z muteksami
d) w kazdej sytuacji dzialaja szybciej niz muteksy
e) oferuja komunikacje miedzyprocesowa

Teoria wielowatkowosci::Ktore z ponizszych zagadnien dotycza programow dzialajacych wspolbieznie:
>>>a) Problem filozofow
>>>b) Problem golibrody
>>>c) Problem nieatomicznosci rozkazow
d) Problem egzystencjalny
e) Problem biurokracji

Mutex::Inicjacjalizacji mutexa z atrybutami domyslnymi mozna dokonac za pomoca instrukcji:?
>>>a) pthread_mutex_init(&mutex, NULL);
b) pthread_mutex_init(&mutex, PTHREAD_MUTEX_INITIALIZER);
c) pthread_mutex_init(&mutex, PTHREAD_MUTEX_DEFAULT);
d) pthread_mutex_init(&mutex, PTHREAD_MUTEX_DEFAULT_ATTR);
>>>e) mutex = PTHREAD_MUTEX_INITIALIZER;
f) mutex = NULL;

Wstrzymywanie::Ktore z podanych funkcji nigdy nie wstrzymuja wykonywania watku, lecz zawsze wracaja natychmiast?
a) int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)
>>>b)int pthread_mutex_trylock(pthread_mutex_t *mutex)
c) int pthread_mutex_lock(pthread_mutex_t *mutex)
>>>d) int sem_getvalue(sem_t *restrict sem, int *restrict sval)
>>>e) int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)
>>>f) int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)

Zmienne warunku (Condition variables)::Ktore funkcje sygnalizuja (niekoniecznie wszystkim) watkom oczekujacym na spelnienie warunku, ze zmienna warunku zostala zmieniona??
a) int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr)
>>>b) int pthread_cond_broadcast(pthread_cond_t *cond)
c) int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)
>>>d) int pthread_cond_signal(pthread_cond_t *cond)


Semafory::Wartosc semafora mozemy ustawic:?
a) Wewnatrz glownej funkcji wykonywanej przez watek, za pomoca funkcji sem_setvalue
>>>b) Przy inicjalizacji semafora
>>>c) W dowolnym miejscu programu (po inicjalizacji semafora), za pomoca funkcji sem_post
d) Wewnatrz funkcji main, za pomoca funkcji sem_setvalue


Mutex::Mozliwe typy (atrybuty) dla muteksa to:?
>>>a) PTHREAD_MUTEX_NORMAL
>>>b) PTHREAD_MUTEX_ERRORCHECK
c) PTHREAD_MUTEX_DEADLKCHECK
>>>d) PTHREAD_MUTEX_RECURSIVE
>>>e) PTHREAD_MUTEX_DEFAULT
f) PTHREAD_MUTEX_DEADLK

::Komunikacja miedzy procesami::Potoki nienazwane moga sluzyc do:
>>>a) przesylania danych na standardowe wejscie innego procesu
b) komunikacji pomiedzy dwoma dowolnymi procesami
c) wyslania sygnalu SIGINT do procesu potomnego
>>>d) komunikacji pomiedzy procesem macierzystym i potomnym
>>>e) przesylania informacji pomiedzy watkami


::Komunikacja miedzy procesami::Funkcja pipe:
a) przyjmuje jako argument trzyelementowa tablice typu int
b) tworzy potok o nazwie podanej jako parametr
>>>c) zwraca 0 gdy operacja przebiegla pomyslnie
d) tworzy dwukierunkowy kanal komunikacyjny
>>>e) jest zwykle stosowana przed funkcja fork


::Komunikacja miedzy procesami::Aby proces macierzysty mogl wysylac dane do swojego potomka potokiem nienazwanym, nalezy:
a) wywolac funkcje pipe zaraz po funkcji fork
>>>b) w kontekscie potomka zamknac koniec potoku przeznaczony do zapisu
c) uzyc funkcji mkfifo
d) uzywac do przesylania danych wylacznie funkcji systemowej write
e) przekazac pid procesu potomnego do funkcji pipe 

::Komunikacja miedzy procesami::Potoki nazwane:
>>>a) sa tez nazywane kolejkami FIFO
>>>b) istnieja fizycznie w systemie plikow
c) sa niszczone w chwili, gdy przestaje z nich czytac ostatni proces
d) potok nazwany nie zostanie stworzony po wywolaniu funkcji pipe, jesli plik o takiej nazwie juz istnieje
e) moga sluzyc do komunikacji tylko pomiedzy dwoma procesami jednoczesnie

::Potoki::Funkcja popen:
>>> a)zwraca uchwyt do pliku jesli zakonczyla sie prawidlowo
>>> b)wywoluje m.in. funkcje pipe()
>>> c)wywoluje m.in. funkcje fork()
d)przyjmuje tylko jeden argument - nazwe polecenia

::Potoki::Funkcja popen:
>>> a) wywoluje fork, a nastepnie exec
>>> b) tworzy lacze komunikacyjne powiazane z innym procesem
c) nie nalezy do biblioteki standardowej
d) zwraca -1 jezeli wystapil blad

::Potoki::Funkcja popen sluzy do:
>>>a) uruchomienia procesu przez utworzenie lacza rozwidlajacego sie przez fork i wywolaniu powloki
b) wywolywania jedynie programow znajdujacych sie w biezacym katalogu
c) powielania derskryptorow plikow
>>>d) wywolania polecenia powloki
e) skrocenia programu (zastepuje funkcje dup, mkfifo i exec)

::Funkcja clone::Funkcja clone:
a) sluzy tylko do tworzenia nowych procesow
b) sluzy tylko do tworzenia nowych watkow
>>>c) sluzy do tworzenia procesow i watkow
d) sluzy do tworzenia nowej instancji obiektu podawanego jako argument funkcji

::Watki::Dany jest fragment kodu:
#include <pthread.h>
//...
void* thread1(void* args) 
do_something();
return NULL;

void* thread2(void* args)
pthread_detach(pthread_self());
do_something();
return NULL;

int main() 
pthread_t t1, t2;
pthread_create(&t1,NULL,&thread1,NULL);
pthread_create(&t2,NULL,&thread2,NULL);
// ---1--
return 0;
Jaki kod powinien sie znalezc w miejscu ---1---, zeby funkcja zadzialala poprawnie:
a) Przede wszystkim, trzeba zmienic wywolanie funkcji pthread_create, poniewaz nie mozna do tej funkcji przesylac wskaznikow pustych.
b) Trzeba dodac dwie linijki:
pthread_join(t1,NULL);
pthread_join(t2,NULL);
c) Trzeba dodac trzy linijki:
void * result;
pthread_join(t1,result);
pthread_join(t2,result);
>>>d) Wystarczy dodac jedna linijke:
pthread_join(t1,NULL);

Teoria watkow::Watki w jednym procesie nie wspoldziela:
>>>a) Maski sygnalow
b) Zmiennych globalnych
>>>c) Stosu
d) Deskryptorow pliku
>>>e) Zmiennej errno

Funkcje "sprzatajace" po watkach::Wywolanie w watku funkcji pthread_cleanup_push(do_something,NULL), a zaraz po niej pthread_cleanup_pop(0) spowoduje, ze:
a) Przy zakonczeniu watku wykona sie funkcja do_something
b) Watek zakonczy sie natychmiast i wykona sie funkcja do_something
>>>c) Przy zakonczeniu watku nie wykona sie funkcja do_something
d) Watek sie nie zakonczy, ale w tym momencie wykona sie funkcja do_something
e) Watek sie zakonczy, a funkcja do_something nie wykona sie

Watki i ich funkcje::Pradziwe sa zdania: 
a) Watki zawsze sa implementowane albo jako watki poziomu uzytkownika, albo jako watki poziomu jadra
b) Wywolanie funkcji pthread_join z pierwszym argumentem -1 spowoduje, ze watek wywolujacy bedzie oczekiwal na zakonczenie wszystkich pozostalych watkow
>>>c) Komunikacja miedzy watkami jest szybsza niz komunikacja miedzy procesami
>>>d) Dzieki mechanizmom danych wewnatrzwatkowych mozna sprawic, ze wybrana zmienna globalna stanie sie niezalezna dla danego watku
>>>e) Do wysylania sygnalow pomiedzy watkami sluzy funkcja pthread_kill

Modele obslugi watkow::W modelu obslugi watkow "wiele na jeden" ... : 
>>>a)...wiele watkow poziomu uzytkownika jest odwzorowywanych na jeden watek jadra
b)...wiele watkow poziomu jadra jest odwzorowywanych na jeden watek uzytkownika
c)...wiele procesow ma jeden watek wykonania
>>>d)...wiele watkow jest wykonywanych w ramach jednego procesu

Konczenie watkow::Watek konczy swoje dzialanie gdy: 
>>>a) zakonczy swoje wykonanie funkcja, ktora wykonywal
>>>b) wywola funkcje pthread_exit
c) zawsze, gdy wywolamy na nim funkcje pthread_cancel

Identyfikatory watkow::Identyfikatory watkow mozna: 
>>>a)uzyskiwac funkcja pthread_self
>>>b)porownywac funkcja pthread_equal
>>>c)wykorzystywac do jednoznacznego identyfikowania watkow

Watki::Watki: 
>>>a) wspoldziela ze soba sekcje danych procesu
>>>b) wspoldziela ze soba sekcje kodu procesu
>>>c) moga posiadac "dane wlasne" - kazdy watek bedzie posiadac ich niezalezna kopie
d) nie moga byc realizowane jako biblioteka na poziomie uzytkownika

Sokety::Tworzac klienta uzywajacego soketow nalezy uzyc funkcji connect gdy korzystamy z:
a) komunikacji bezpolaczeniowej
>>>b) komunikacji strumieniowej
>>>c) komunikacji za pomoca protokolu TCP
d) komunikacji za pomoca protokolu UDP

Sokety::Podajac adres do komunikacji nalezy pamietac o tym ze:
a) nie moze on byc adresem z sieci lokalnej
b) nie mozna go uzywac wielokrotnie
>>>c) mozna go pobrac z adresu postaci www.strona.pl za pomoca funkcji gethostbyname
>>>d) mozna go pobrac z adresu w formie ip (czyli xxx.xxx.xxx.xxx) za pomoca funkcji inet_aton
>>>e) moga wystepowac rozne sposoby zapisu danych binarnych i nalezy sie upewnic ze podawany adres jest w postaci uzywanej w sieci

Sokety::Funkcja accept:
>>>a) zwaraca nowy soket ktorego uzywamy do wlasciwej komunikacji
>>>b) wymaga najpierw wywolania funkcji listen na sokecie
>>>c) ulatwia komunikacje z wieloma polaczeniami naraz w obrebie jednego programu
d) nalezy ja wywolac w kliencie bezposrednio po stworzeniu soketu
e) nie jest funkcja ktora dotyczy zagadnienia soketow
f) jest zawsze wymagana do komunikacji

::Sokety::Stworzenie soketu z PF_INET6 jako rodzina protokolu komunikacji:
>>>a) jest poprawne
>>>b) tworzy nam lacze korzystajac z IPv6
c) umozliwa komunikacje za pomoca IPv6 oraz IPv4
d) tworzy lacze strumieniowe
e) tworzy lacze lokalne
f) tworzy lacze AppleTalk 

::Watki::Do synchronizacji watkow mozemy wykorzystac:
>>>a) semafory
>>>b) funkcje pthread_join()
c) funkcje zawarte w pliku naglowkowym pthread_synch.h
>>>d) zmienne warunku
>>>e) mutexy

::Inicjalizacja mutexa wartosciami domyslnymi::Mutex mozemy zainicjalizowac wartosciami domyslnymi w nastepujacy sposob:
a) pthread_mutex_t mutex = PTHREAD_DEFAULT_MUTEX_INITIALIZER
>>>b) pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
>>>c) za pomoca funkcji pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr), gdy drugi parametr jest rowny NULL
d) za pomoca funkcji pthread_mutex_init(pthread_mutex_t *mutex)
>>>e) poprzez wykonanie ciagu instrukcji:
 pthread_mutex_t mutex;
 pthread_mutexattr_t mta;
 pthread_mutexattr_init(&mta);
 pthread_mutex_init(&mutex, &mta);

::Wielokrotne zamykanie mutexa::Wielokrotne zamykanie jednego mutexa przez ten sam watek...
a) spowoduje zwrocenie bledu ELOCKED, jesli mutex jest mutexem sprawdzajacym bledy
>>>b) spowoduje zablokowanie sie watku, jesli mutex jest mutexem szybkim
c) powoduje anulowanie pozostalych watkow
>>>d) nie spowoduje zablokowania sie watku, jesli mutex jest rekurencyjny
e) bedzie mialo rezultat zalezny od ustawionej zmiennej warunku

::Operacje na semaforach (POSIX)::W przypadku semaforow standardu POSIX:
>>>a) funkcja sem_wait() blokuje watek, az semafor bedzie mial wartosc dodatnia
b) funkcja sem_post() stanowi zadanie przydzielenia zasobow (licznik semafora jest dekrementowany)
c) funkcja sem_trypost() jest nieblokujaca wersja sem_post()
d) funkcja sem_destroy() moze byc uzywana do niszczenia semaforow niezaleznie od ich stanu
>>>e) funkcja sem_trywait() powraca z bledem EAGAIN, jesli licznik semafora jest rowny zero

::Watki::Ktore z ponizszych zdan dotyczacych funkcjipthread_cond_signal(pthread_cond_t *cond) i pthread_cond_broadcast(pthread_cond_t *cond) sa prawdziwe?
a) funkcja pthread_cond_signal() obudzi watek, ktory pierwszy wywolal pthread_cond_wait() na zmiennej warunku cond
b) funkcja pthread_cond_signal() zwroci blad, jesli zaden watek nie czeka na zmiennej warunku cond
>>>c) funkcja pthread_cond_broadcast() obudzi wszystkie watki czekajace na zmiennej warunku cond
>>>d) funkcja pthread_cond_broadcast() nie zwroci bledu, jesli zaden watek nie czeka na zmiennej warunku cond
>>>e) deklaracje tych funkcji znajduja sie w pliku naglowkowym pthread.h

::Watki::Watek anulowane synchronicznie: 
a) po otrzymanu zadania anulowania natychmiast konczy swoja prace
>>>b) moze zostac zakonczony tylko w wyznaczonych punktach
c) konczy swoje dzialanie rownoczesnie z watkiem, ktory go anulowal
>>>d) konczy dzialanie po dotarciu do funkcji void pthread_testcancel(void)
e) konczy dzialanie po dotarciu do funkcji void pthread_cancel(pthread_t tid)

::Watki::Jesli proces ma kilka watkow, to gdy zostanie do niego wyslany sygnal:
a) Zawsze otrzymuje go najstarszy watek.
b) Wedlug standardu POSIX otrzymuje go najmlodszy watek.
>>>c) W systemach linuxowych otrzymuje go najstarszy watek.
d) Wedlug standardu POSIX otrzymuje go najstarszy watek.
>>>e) Stadnadrd POSIX nie precyzuje, ktory z watkow otrzyma dany sygnal.

::Watki::Watki nalezace do tego samego procesu:
a) Wspoldziela ze soba stos procesu nadrzednego.
b) Otrzymuja kopie wszystkich zasobow systemowych procesu nadrzednego
>>>c) Kazdy z watkow posiada wlasny niezalezny stos.
>>>d) Zasoby systemowe procesu sa dzielone miedzy jego watki.
>>>e) Moga posiadac dane prywatne skojarzone z pewnymi kluczami dostepne tylko w watku, ktory dokanal takiego skojarzenia

::Watki::Wskaz prawdziwe zdania:
a) Do ustawiania atrybutow watku sluzy funkcja int pthread_set_attr(pthread_attr_t *attr)
>>>b) Atrybuty sa przechowywane w strukturze typu pthread_attr_t
>>>c) Atrybuty inicjalizuje sie domyslnymi wartosciami funkcja int pthread_attr_init(pthread_attr_t *attr)
d) Atrybuty inicjalizuje sie domyslnymi wartosciami funkcja int pthread_attr_default(pthread_attr_t *attr)
>>>e) Dla kazdego atrybutu istnieje funkcja pobierajaca i ustawiajaca jego wartosc.

::Watki::Czym roznia sie watki poziomu uzytkownika od watkow poziomu jadra
>>>a) Szybciej odbywa sie przelaczanie miedzy watkami poziomu uzytkownika
b) Szybciej odbywa sie przelaczanie miedzy watkami poziomu jadra
>>>c) W przypadku watkow poziomu jadra zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
d) W przypadku watkow poziomu uzytkownika zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
>>>e) Watki poziomu jadra sa obslugiwane jaka pracujace w obrebie tej samej przestrzeni adresowej procesy.

::Sockety::Przesylanie danych przez gniazdko w trybie connection-oriented (SOCK_STREAM) w domenie Internetu:
>>> a) Powoduje, ze u odbiorcy dostajemy ten sam ciag bajtow, ktory wyslalismy
>>> b) Moze doprowadzic do blednej interpretacji liczb u odbiorcy (o ile nie zabezpieczymy sie przed tym)
c) Wymaga dopisywania do przesylanych danych naglowka warstwy transportu (numery segmentow, flagi protokolu TCP itd.)
>>> d) Wymaga istniejacego polaczenia pomiedzy gniazdkami nadawcy i odbiorcy
e) Jest mozliwe tylko wtedy, gdy gniazko odbiorcy znajduje sie na <b>innym</b> komputerze

::Sockety::Poprawna sekwencja wywolan po stronie serwera, prowadzaca do akceptacji polacznia od klienta w strumieniowym trybie komunikacji (SOCK_STREAM):
a) socket, listen, accept, bind
b) listen, socket, bind, accept
>>> c) socket, bind, listen, accept
d) bind, socket, accept, listen

::Sockety:Przy korzystaniu z gniazd domeny Unixa:
>>> a) Mozemy utworzyc gniazdko w dowolnym miejscu struktury katalogow, do ktorego mamy prawa zapisu
b) Nie ma zadnych ograniczen przy tworzeniu gniazdek
>>> c) Do identyfikacji klienta nie powinno sie uzywac parametrow niezaleznych tylko w obrebie systemu (np. PID), poniewaz w przyszlosci komunikacja miedzy dwoma maszynami przez gniazdko na sieciowym systemie plikow moze stac sie mozliwa
d) Nie jest mozliwe korzystanie z trybu connecionless (SOCK_DGRAM)

::Sockety::Korzystanie z protokolu TCP przy gniazdkach:
a) jest niemozliwe
b) jest mozliwe w dziedzinie UNIX w trybie connection-oriented (SOCK_STREAM)
c) jest mozliwe w dziedzinie Internetu w trybie connectionless (SOCK_DGRAM)
>>> d) jest mozliwe w dziedzinie Internetu w trybie connection-oriented (SOCK_STREAM)
>>> e) TCP jest domyslnym protokolem dla odpowiedniej pary dziedzina - tryb komunikacji

::Sockety::Zaakceptowanie polaczenia na sockecie (accept):
>>>a) Powoduje powstanie nowego otwartego deskryptora
b) Uniemozliwia zaakceptowanie nowego polaczenia na sockecie nasluchujacym przed zakonczeniem tego, ktore wlasnie przyjelismy
>>>c) Sprawia, ze komunikacja z klientem bedzie odbywac sie przez nowy deskryptor
d) Umozliwia komunikacje z klientem zarowno przez deskryptor zwrocony przez accept, jak i przez ten, na ktorym polaczenie zostalo odebrane

::Sockety::Aby zaakceptowac polaczenie i umozliwic komunikacje nalezy wywolac funkcje :
>>> a) accept
b) connect
c) setsockopt

::Sockety::Typ gniazdka decyduje o tym w jaki sposob beda przekazywane dane. Dopuszczalne wartosci to:
>>>a) SOCK_STREAM
>>>b) SOCK_RAW
c) PF_PACKET
d) SOCK_DATGRAM

::Sockety::Funkcja bind sluzy do:
a) tworzenia socketu
b) nasluchiwania polaczen
c) odbierania i wyswietlania danych
>>>d) przyznania nazwy socketowi

::Sockety::W funkcji socket:
>>>a) pierwszy parametr okresla rodzine protokolow komunikacji
>>>b) parametr protocol jest zazwyczaj rowny 0
c) uzycie jako pierwszego parametru PF_INET6 sluzy do komunikacji w obrebie tylko jednej maszyny
>>>d) parametr type okresla typ socketu

::Sockety::Zaznacz prawidlowa odpowiedz:
a) Poniewaz sockety datagramowe wymagaja polaczenia, musimy na nie poczekac wywolujac funkcje listen()
b) sockety umozliwiaja komunikacje miedzy procesami tylko poprzez siec
c) do komunikacji miedzyprocesowej poprzes siec sluzy domena Unixowa
>>>d) nadanie nazwy socketowi odbywa sie przy pomocy funkcji bind()
e) nadanie nazwy socketowi odbywa sie przy pomocy funkcji socket()

::Struktury IPC::Do struktur IPC naleza: ?
a) sockety
>>>b) kolejki komunikatow
>>>c) pamiec wspolna
d) strumienie
>>>e) semafory
f) potoki

::Kolejki komunikatow::Kolejke komunikatow moze usunac: ?
a) kazdy
>>>b) proces, ktorego obowiazujacy identyfikator uzytkownika jest rowny msg_perm.cuid
>>>c) proces, ktorego obowiazujacy identyfikator uzytkownika jest rowny msg_perm.uid
d) proces, ktorego identyfikator grupy jest rowny msg_perm.gid
>>>e) proces majacy uprawnienia nadzorcy

Semafory:: wywolanie funkcji int semget (key_t key,int nsems, int flag): ?
>>>a) zwroci -1 w przypadku wystapienia bledu
b) zawsze utworzy nowa strukture IPC
>>>c) zwroci identyfikator semafora, gdy wszystko w porzadku
d) zwraca 0 gdy semafor o podanym kluczu juz istnieje

Pamiec wspolna:: W funkcji int shmctl (int shmid, int cmd, struct shmid_ds *buf) aby pobrac do buf strukture semid_ds nalezy uzyc opcji?
>>>a) IPC_STAT
b) IPC_SET
c) IPC_RMID
d) GETVAL
e) GETALL

Struktury IPC::Prawda jest, ze: ?
>>>a) mozliwe jest usuniecie kolejki komunikatow, nawet gdy sa procesy, ktore beda z niej korzystac
>>>b) pamiec wspolna moze uzywac do synchronizacji semaforow
>>>c) przy tworzeniu struktury IPC podajac klucz o wartosci IPC_PRIVATE mamy pewnosc, ze powstanie nowa struktura IPC
d) ilosc semaforow w systemie jest nieograniczona
>>>f) funkcja semop realizuje w sposob atomowy operacje na zbiorze semaforow

Jaka funkcja mozna wyslac dane do gniazda BEZPOLACZENIOWEGO? 
a) sck_snd(int, const void *, size_t)
b) write(int, const void *, size_t)
>>>c) send(int, const void *, size_t, int)
>>>d) sendto(int, const void *, size_t, int, const struct sockaddr*, socklen_t)

Podczas tworzenia socketu domena PF_UNIX w pierwszym argumencie odpowiada: 
a) komunikacji miedzy procesami systemu UNIX na roznych hostach.
b) komunikacji miedzy procesami dowolnych systemow na roznych hostach wedlug specyfikacji POSIX.
>>>c) komunikacji miedzy procesami dzialajacymi na tym samym hoscie.
d) komunikacji miedzy procesami systemu UNIX na roznych hostach kontrolowanej na niskim poziomie.
>>>e) komunikacji bedacej socketowym odpowiednikiem potokow (pipe)

Ktory z podanych typow gniazd jest najszybszy? 
a) polaczeniowe, strumieniowe (SOCK_STREAM)
>>>b) bezpolaczeniowe, niepewne (SOCK_DGRAM)
c) polaczeniowe, pakietowe (SOCK_SEQPACKET)
d) bezpolaczeniowe, pewne (SOCK_DRM)

Ktore z funkcji socket() i bind() musza znac strukture sock_addr, ktora chcemy zwiazac z gniazdem. 
a) Funkcja socket zna protokol oraz adres. Funkcja bind() rejestruje gotowe gniazdo do komunikacji, a system rozpoznaje adres na podstawie deskryptora gniazda.
b) Funkcja socket zna protokol oraz adres. Funkcja bind() rejestruje gotowe gniazdo ale DOSTAJE adres w argumencie, gdyz system nie odroznia dekstryptorow gniazd od deskryptorow plikow.
>>>c) Struktura sock_addr jest potrzebna do zerejestrowania gniazda w systemie funkcja bind(). Socket() zna jedynie protokol.
d) Struktura sock_addr jest wartoscia zwracana funkcji bind(). Socket() zna jedynie protokol.

Ktore z nastepujacych rodzin protokolow sa BLEDNE? 
a) PF_APPLETALK
b) PF_UNIX
c) PF_INET7
>>>d) PF_WIN

::POSIX::Komunikat znajdujacy sie w kolejce POSIX posiada nastepujace parametry:
>>>a) priorytet bedacy calkowita liczba bez znaku
>>>b) rozmiar obszaru danych w komunikacie
>>>c) dane
d) deskryptor pliku
e) numer kolejki

::POSIX::O POSIX-ie mozna powiedziec, ze:
>>>a) posiada mozliwosc powiadomienia o pojawieniu sie sygnalu w kolejce
b) nie obsluguje kolejek komunikatow
>>>c) posiada mozliwosc komunikacji miedzyprocesowej przy pomocy pamieci wspolnej
>>>d) ma wbudowana obsluge semaforow
e) rozwijamy skrot jako Port Operated Simultaneous Interface
>>>f) znany jest pod nazwa IEEE 1003

::POSIX::Nastepujace stwierdzenia dotyczace funkcji 'shm_unlink' sa prawdziwe:
>>>a) usuwa nazwe obiektu w pamieci wspolnej
b) zwraca deskryptor obiektu
>>>c) po jej wykonaniu, kolejne wywolania open nie powioda sie
>>>d) jako argument funkcja przyjmuje nazwe obiektu
e) pozwala zmodyfikowac flagi obiektu

::POSIX::Kolejki komunikatow mozemy wykorzystywac do:
>>>a) przesylania komunikatow miedzy procesami
b) ustalania zmiennych systemowych
>>>c) przesyla porcji bajtow skladajacych sie na komunikat
d) operacji na pamieci wspolnej

::POSIX::Nastepujace stwierdzenia dotyczace semaforow sa prawdziwe:
>>>a) sa podstawowym elementem sluzacym do synchronizacji roznych procesow
>>>b) rozrozniamy semafory nazwane i wystepujace w pamieci operacyjnej
>>>c) funkcja sem_destroy usuwa semafor z pamieci
d) funkcja sem_unlink usuwa semafor z pamieci
>>>e) funkcje obslugi semaforow znajduja sie w pliku nglowkowym <semaphore.h>

6. Wskaz BLEDNE zdanie(a):
>>> a) analogicznie jak kolejki FIFO, potoki nienazwane umozliwiaja komunikacje miedzy procesami niespokrewnionymi
>>> b) na laczu komunikacyjnym mozna wykonywac funkcje takie jak: write, read, lseek
 c) istnieja tylko póldupleksowe potoki nienazwane
>>> d) potoki nienazwane, podobnie jak kolejki FIFO, moga byc identyfikowane przez nazwe

Funkcja int pthread_mutex_trylock(pthread_mutex_t *mutex); 
>>a) Nie moze zablokowac watku 
b) Moze zablokowac caly proces 
c) Zawsze zwraca 0 
>>d) Poprawnie wykorzystana zapobiega odwolaniu sie przez dwa watki do tego samego miejsca w pamieci 

Metody zakonczenia watku to:
>>>a) pthread_exit z wattku ktory chcemy zakonczyc 
b) pthread_exit z watku zewnetrznego
>>>c) pthread_cancel z watku zewnetrznego 
>>>d) return z procedury startowej watku 

::IPC - system V:: Do tworzenia kolejki komunikatów w systemie, sluzy funkcja: int msgget (key_t key, int flag) zwracajaca identyfikator kolejki lub -1.
a) argument flag pozwala okreslic maksymalna liczbe komunikatów, które moga znalezc sie w kolejce
b) kolejka zostanie zawsze stworzona, gdy zostanie podany dodatni calkowity klucz oraz jedna z flag bedzie IPC_CREAT
>>> c) podanie klucza równego wartosci symbolicznej IPC_PRIVATE gwarantuje stworzenie nowej kolejki
>>> d) argument flag pozwala okrsesic prawa dostepu do kolejki
e) argument flag pozwala okreslic prawa dostepu do kolejki
f) do kolejki, od tej pory, funkcje systemowe uzyskuja dostep zarówno przez klucz, jak i przez zwrócony przez msgget identyfikator

Stan "odlaczenia" watku::Gdy watek znajduje sie w stanie "odlaczonym" (detached):
>>>a) pamiec po nim zostanie zwolniona od razu po zakonczeniu jego dzialania
b) bedzie mozna pobrac wartosc przez niego zwrocona funkcja pthread_join
>>>c) mozna zakonczyc program nie oczekujac na zakonczenie watku funkcja pthread_join 

Sokety::Soketow w systemie Linux mozna uzywac do:
>>>a) komunikacji przez siec za pomoca protokolu TCP
>>>b) komunikacji przez siec za pomoca protokolu UDP
>>>c) komunikacji w obrebie jednego komputera
>>>d) podsluchiwania danych przechodzacych przez karte sieciowa
e) podsluchiwania wszystkich operacji dziejacych sie na komputerze

3.Jakim poleceniem tworzy sie potoki nazwane?
a)pipe
b)namepipe
>>> c)mkfifo

5. Sytuacja wyscigu (w kontekscie procesow) charakteryzuje sie tym, ze:
a) Procesy wysciguja sie, ktory bedzie szybszy i ktory zapisze szybciej na dysk plik. Proces wygrany, dostaje nagrode w postaci cukierka.
>>> b) Wiele procesow probuje wykonac jakies operacje na wspolnych danych i koncowy wynik zalezy od kolejnosci realizacji procesow
>>> c) Niepewnoscia, ktory proces zakonczy sie najpierw
>>> d) Mozna jej zaradzic uzywajac funkcji wait lub waitpid

1.Polecenie ftok:
a) sluzy do umieszczania danych w kolejce komunikatow.
>>>b) generuje klucz na podstawie nazwy sciezki i identyfikatora projektu
d) powoduje zmiane klucza juz utworzonego obiektu mechanizmu IPC
d) wyswietla informacje o wszystkich obiektach IPC istniejacych w systemie

2.Utworzenie nowego zestawu semaforow lub dostep do juz istniejacej zapewnia funkcja:
a)semcrt
b)semmk
>>> c)semget
d)semctl
e)semset

3.Ktore zdanie jest prawdziwe?
>>> a) Wywolanie funkcji msgsnd sluzy do umieszczania danych wkolejce komunikatow
b)funkcja msgsnd zwraca identyfikator kolejki komunikatow
c)funkcja msgrcv sluzy do ustawiania atrybutow kolejki
>>> d)struktura msqid_ds definiuje biezacy stan kolejki

4.Proces wywolujacy funkcje shmat:
>>> a) dolacza juz istniejacy segment pamieci do swojej przestrzeni adresowej
b) odlacza segment pamieci od swojej przestrzeni adresowej 
c) usuwa segment z jadra systemu
d) tworzy nowy segment pamieci dzielonej

1. Do czego sluzy funkcja ftok:
a) wysylania komunikatow
b) niszczenia semaforow
>>> c) generowania klucza
d) generowania id obiektu ipc

Proces A zamyka MUTEX M. W ktorych z przypadkach watek A lub B zostanie zablokowany, jezeli nastepnie: 
>>> a) A sprobuje zamknac M funkcja pthread_mutex_lock i M jest MUTEXem szybkim 
b) A sprobuje zamknac M funkcja pthread_mutex_lock i M jest MUTEXem rekurencjyjnym 
>>> c) B sprobuje zamknac M funkcja pthread_mutex_lock i M jest MUTEXem rekurencyjnym 
d) B sprobuje zamknac M funkcja pthread_mutex_trylock i M jest MUTEXem szybkim 

Watek asynchronicznie anulowalny 
a) Jest domyslnym rodzajem watku 
>>> b) Zostaje anulowany natychmiast po otrzymaniu zadania anulowania 
c) Zostaje anulowany dopiero po dotarciu do wyznaczonego miejsca 
d) Nie moze byc anulowany 

15 Watek zostaje zakonczony:
>>> a) Po wywolaniu funkcji execv z tego watku
>>> b) W chwili dotarcia do konca funkcji watku
>>> c) Po wywolaniu funkcji execl z jakiegos innego watku tego samego watku
>>> d) Po wywolaniu funkcji pthread_exit

1. Lacza komunikacyjne sa:
>>> a) poldupleksowe
b) dwukierunkowe
c) moga byc stosowane tylko przez procesy majace wspolnego potomka
d) zadna z odpowiedzi nie jest poprawna 

2.W przypadku lacza od procesu macierzystego do potomnego proces:
a) macierzysty zamyka koniec lacza do zapisu
b) potomny zamyka koniec lacza do odczytu
>>>c) macierzysty zamyka koniec lacza do odczytu
d) potomny otwiera koniec lacza do zapisu

3.Dla lacza, ktorego koniec do zapisu zostal zamkniety, funkcja read po przeczytaniu wszystkich danych przekazuje:
a) wartosc -1, aby wskazac blad
>>> b) wartosc 0, aby wskazac koniec pliku
c) liczbe odczytanych znakow
d) zadna z odpowiedzi nie jest prawdziwa

4.Jesli jako tryb w funkcji popen podamy paramatr:
a) "r", to nasz program bedzie zapisywac polecenia do standardowego wyjscia
b) "r", to nasz program bedzie odczytywal dane ze standardowego wejscia polecenia powloki
>>> c) "w", to nasz program bedzie zapisywac polecenia do standardowego wejscia
d) "w", to nasz program bedzie odczytywal dane ze standardowego wejscia 
 
5.Kolejka FIFO:
>>>a) moze byc otwarta za pomoca funkcji open
>>>b) moze do niej pisac lub czytac jeden lub wiecej procesow
>>>c) jest traktowana jak zwykly plik
d) zadna nie jest poprawna

2. Watki jednego procesu NIE dziela 
a) sekcji danych (zmienne globalne itd)
b) sekcji kodu programu- kod jest kopiowany dla kazdego watku osobno
>>>c) stosu - gdyby dzielily nie moglyby wywolywac roznych funkcji w roznych watkach
d) watki nic nie dziela miedzy soba

5. Identyfikator watku jest typu
a) zawsze typu int
>>> b) pthread_t 
c) thread
d) pid_t - taki sam typ jak dla procesu ale inna wartosc

3. Zakladamy, ze funkcje alocate_buffer oraz temp_bufferodpowiednio alokuja i zwalnia pamiec zajeta przez bufor podany w parametrze. Wywolanie funkcji
do_some_work:
void do_some_work ()
 void *temp_buffer = alocate_buffer(1024);
 pthread_cleanup_push (dealloc_buffer, temp_buffer);
 /* jakies operacje na temp_buffer */
 pthread_cleanup_pop (0);
spowoduje:
a) Zaalokowanie bufora, wykonanie na nim operacji oraz jego zwolnienie
b) Blad w czasie kompilacji
>>>c) Zaalokowanie bufora i wykonanie na nim operacji bez zwolnienie pamieci
>>>d) Zarejestrowanie procedury czyszczacej
>>>e) Wyrejestrowanie procedury czyszczacej

1. Wspolnym terminem struktury IPC okreslamy:
a) kolejki komunikatow, kolejki FIFO, pamiec dzielona
b) kolejki komunikatow, pamiec dzielona, mechanizm ryglowania rekordow
d) kolejki FIFO, mechanizm ryglowania rekrdow, pamiec dzielona
>>d) kolejki komunikatow, semafory, pamiec dzielona

1. Ile razy mozna odczytac dane ktore juz raz byly z potoku odczytane (ponowna proba odczytu wczesniej odczytanych danych)?
a) nieskonczona ilosc razy
b) raz
>>>c) nie mozna ponownie odczytac tych samych danych
d) zadna z odp nie jest poprawna

2. Co sie dzieje z danymi odczytanymi z potoku?
a) sa nadal przechowywane w potoku,
>>> b) sa kasowane,
c) sa zapisywane do pliku tymczasowego,
d) odp a i c sa poprawne.

4. W jakich pzypadkach mozna uzywac plikow FIFO?
>>> a) w komunikacji "przodek"<=>"potomek",
>>> b) w komunikacji miedzy dowolnymi dzialjacymi procesami,
c) w komunikacji miedzy procesem a plikiem.

5.Do czego sluzy funkcja select?
a) funkcja umozliwia przelaczanie sie miedzy procesami,
>>> b) funkcja umozliwia korzystanie z wielu potokow rownoczesnie,
c) funkcja umozliwia wyjscie z pipe'a.

1. Proces to:
a) Program na dysku.
>>> b) Dzialajaca kopia jakiegos programu.
c) Program na dyskietce.
d) Program na cdromie, pod warunkiem ze cdrom jest nagrany w formacie iso.

2. Unikatowy numer, ktory otrzymuje kazdy nowo tworzony proces, nazywa sie:
a) GID
b) SID
c) UID
>>> d) PID
e) KID
f) DID
g) HID

3. Uzytkownik po wykonaniu polecenia ps -aux zobaczyl ku przerazeniu literki Z w polu STAT. Co sie stalo?
a) System zostal zawirusowany przez Bila Gatesa
b) Jakis wredny szpieg przejal sesje ssh i zmienil pola STAT
>>>c) Proces macierzysty nie oczekiwal na potomnego i w konsekwencji potomny zaczal straszyc inne procesy stajac sie ZOMBIE.
d) Nie jest mozliwe otrzymanie w wyniku polecenia ps literki Z

4. Segment TEKSTU (w kontekscie obszaru pamieci przeznaczonego dla procesu) to:
a) Miejsce, gdzie znajduja sie zmienne automatyczne oraz informacje zwiazane z kazdym wywolaniem fukncji
>>> b) Miejsce, gdzie znajduja sie instrukcje maszynowe
c) Dane, ktore w sosob jawny inicjowane sa w programie
d) Nie ma czegos takiego, pytanie jest zle sformulowane, nie ma w ogole o czym rozmawiac!

2. Za pomoca jakiego makra mozemy zidentyfikowac kolejke FIFO?
>>> a) S_ISFIFO
b) S_ISSOCK
c) S_ISREG
d) S_ISBLK

3. Ktore zdania dotyczace kolejek FIFO sa poprawne?
a) kolejki moga byc uzywane jedynie do komunikacji miedzy procesami spokrewnionymi
>>> b) kolejka FIFO ma swoj typ pliku
c) jedna kolejke FIFO mozna jednoczesnie otworzyc zarowno do zapisu jak i do odczytu
>>> d) aby moc korzystac z utworzonej kolejki FIFO (poprzez funkcje mkfifo) trzeba ja otworzyc wywolujac funkje open

4. Ktora(e) z funkcji sluza do utworzenia potoku nienazwanego oraz otwarcia go:
>>> a) int pipe(int filedes[2])
>>> b) FILE* popen(const char *cmd, const char *type)
c) int dup(int filedes)
d) int mkfifo(const char *path, mode_t mode)

5. Co nalezy zrobic w przypadku kiedy kilka procesow probuje zapisac dane do FIFO, a zalezy nam aby dane nie ulegly wymieszaniu?
a) uzyc sygnalizatora O_NONBLOCK
>>> b) zadbac o to, aby zapisywane bloki mialy mniejszy rozmiar niz stala PIPE_BUF
c) nie trzeba nic robic, system sie o to troszczy
d) taki problem nie istniej, poniewaz nie moze zachodzic sytuacja, w ktorej dwa procesy naraz zapisuja do kolejki

1. Jaka funcja sluzy do tworzenia semaforow?
>>> a) semget()
b) semctl()
c) semop()
d) semctl() z odpowiednia opcja

2.Kolejki komunikatow. Ktore zdanie jest prawdziwe?
a) msgctl() moze sluzyc do wysylania komunikatow
>>> b) msgctl() moze sluzyc do usuwania kolejki komunikatow
>>> c) kazda kolejka posiada swoj identyfikator
>>> d) msgget() sluzy do tworzenia kolejki komunikatow

3. Pamiec dzielona:
>>> a) wymaga synchronizacji przy zapisywaniu i odczytywaniu z niej
b) jest przylaczana do procesu za pomoca funkcji shmget()
>>> c) umozliwia korzystanie z segmentu pamieci wielu procesom
d) nie moga z niej korzystac procesy potomne

4. Wyrozniamy 2 podstawowe operacje na semaforach:
>>> a) wejscie do sekcji krytycznej - wartosc semafora jest dekrementowana
>>> b) opuszczenie sekcji krytycznej - wartosc semafora jest inkrementowana
c) wejscie do sekcji krytycznej - wartosc semafora jest inkrementowana
d) opuszczenie sekcji krytycznej - wartosc semafora jest dekrementowana

5. Zasoby IPC. Ktore zdanie jest prawdziwe?
>>> a) klucz do zasobu IPC jest generowany na podstawie nazwy istniejacego pliku i dowolnej liczby calkowitej
b) kolejka komunikatow jest usuwana z pamieci po zakonczeniu procesu ktory operowal na niej
>>> c) flaga IPC_CREAT oznacza ze jesli zasob o podanym kluczu nie istnieje, to zostanie utworzony.
>>> d) flaga IPC_PRIVATE oznacza ze z zasobu moze kozystac tylko dany proces oraz jego procesy potomne

1. Ktore z ponizszych zdan jest prawdziwe:
>>> a) funkcja dup2() jest operacja atomowa 
>>> b) funkcja dup() jest operacja atomowa 
c) funkcje dup() oraz dup2() sluza do wysylanie danych dokolejki FIFO 

2. Ktore z ponizszych zdan jest nieprawdziwe: 
a) Lacza komunikacyjne sa przekazywane tylko w jednym kierunku 
b) Moga byc stosowane tylko przez proces majacy wspolnego przodka 
>>> c) Nie istnieje niebezpieczenstwo wymieszanie przesylanych danych naszego zapisu z zapisem danych z innego 

3. Ktore z ponizszych dokonczen zdania jest prawdziwe: "Koproces jest programem, ktory... "
>>> a) czyta ze stadnardowego WE i pisze na standardowe WY 
b) procesem wielokrotnie sie wykonujacym 
c) jest rodzajem demona 

4. Ktore z ponizszych zdan jest prawdziwe: 
>>> a) po utworzeniu kolejki za pomoca mkfifo() nalezy ja otworzyc poleceniem open() 
>>> b) wartosc pola st_mode S_ISFIFO oznacza, ze mamy do czynienia z plikiem FIFO 
c) wartosc pola st_mode S_ISQUE oznacza, ze mamy do czynienia z plikiem FIFO 
d) po utworzeniu kolejki za pomoca mkfifo() nalezy ja otworzyc poleceniem nextfifo() 

5. Ktore z ponizszych zdan jest prawdziwe: 
a) polecenie mkfifo potrafi stworzyc pliki specjalne blokowe lub znakowe
>>> b) polecenie mknod potrafi stworzyc pliki specjalne blokowelub znakowe 
>>> c) jezeli proces chce zapisac mniejsza liczbe danych niz wynosi ilosc wolnego miejsca, to zostanie zapisane do lacza tyle bajtow ile proces chcial 
d) jezeli proces chce zapisac mniejsza liczbe danych niz wynosi ilosc wolnego miejsca, to proces sie zakonczy bez zapisania danych 

2. Ktora z ponizszych funkcji sluzy do odbierania komunikatow z kolejki:
a) semop
b) msgget
>>> c) msgrcv
d) printf

4. W jakiej strukturze jadra jest przechowywany zestaw semaforow:
a) sem
b) sembuf
>>> c) semid_ds
d) CSemSet
e) semafor
f) semfors_id

5. Ktory sposob komunikacji miedzy-procesowej jest najszybszy?
a) semafory
>>>b) pamiec wspoldzielona
c) kolejki komunikatow
d) potoki
f) alfabet morse'a

1. Metody zakonczenia watku to:
>>>a) pthread_exit z watku ktory chcemy zakonczyc
b) pthread_exit z watku zewnetrznego
>>>c) pthread_cancel z watku zewnetrznego
>>>d) return z procedury startowej watku

2. Co robi funkcja int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut); :
>>>a) zdejmuje blokade z mutexu mut
b) czeka okreslony przedzial czasu
>>>c) czeka na sygnal na zmiennej warunkowej cond
>>>d)jest cancel-pointem ( watek w czasie blokady na tej funkcji moze zostac anulowany )

3. Ktore z podanych funkcji sa cancel-pointami ( watki w czasie wykonywania tych funkcji moga zostac anulowane ) :
>>>a) pthread_cond_wait
b) pthread_mutex_lock
>>>c) pthread_testcancel
d) sleep

4. Do pobrania id watku biezacego sluzy:
a) pthread_getid
b) pthread_myself
>>>c) pthread_self 
d) zadna

5. Dostepna dla zwyklego uzytkownika polityka schedulera jest:
>>> a) SCHED_OTHER v
b) SCHED_RR
c) SCHED_FIFO
d) zadna z powyzszych

::IPC - system V:: Wywolanie: msgget(1234, O_CREAT|O_EXCL|0600)
a) gwarantuje stworzenie kolejki o kluczu 1234 do odczytu i zapisu wylacznie dla procesów tworzacego ja uzytkownika
b) gwarantuje stworzenie kolejki o identyfiaktorze 1234 do odczytu i zapisu wylacznie dla procesów tworzacego ja uzytkownika
>>> c) zwróci identyfikator kolejki o kluczu 1234, o ile kolejka nie istnieje
d) pobiera z kolejki o identyfikatorze 1234 komunikat
e) zadne z powyzszych stwierdzen nie jest prawdziwe
f) zwróci identyfikator kolejki o kluczu 1234, o ile kolejka istnieje 
 
2. Z kolejki komunikatow mozemy odczytac:
>>>a) pierwszy komunikat
b) ostatni komunikat
>>>c) pierwszy komunikat ktorego typ wynosi 5
>>>d) pierwszy komunikat ktorego typ jest rozny od 5
>>>e) pierwszy komunikat ktorego typ nie przekracza 5

3. Co wyniknie z wywolania semget(12, 34, O_CREAT|0600); ?
a) Funkcja zawsze zwroci blad
>>>b) Funkcja zwroci identyfikator zestawu semaforow o kluczu 12 (o ile istnieje)
c) Funkcja zwroci identyfikator zestawu semaforow o kluczu 34 (o ile istnieje)
d) Funkcja utworzy zestaw 12 semaforow o kluczu 34 (jesli nie istnieje)
>>>e) Funkcja utworzy zestaw 34 semaforow o kluczu 12 (jesli nie istnieje)

4. Ktora z ponizszych operacji moze zablokowac proces:
struct sembuf buf;
buf.sem_num = 0;
buf.sem_flg = 0;
a) buf.sem_op = 1; semop(id, &buf, 1);
>>>b) buf.sem_op = 0; semop(id, &buf, 1);
>>>c) buf.sem_op = -1; semop(id, &buf, 1);
d) buf.sem_op = -5; buf.sem_flg = IPC_NOWAIT; semop(id, &buf, 1);
e) buf.sem_op = 5; buf.sem_flg = IPC_NOWAIT; semop(id, &buf, 1);

5. Co wyniknie z wywolania: shmctl(1234, IPC_RMID, NULL);
a) Funkcja zawsze zwroci blad
b) Funkcja natychmiast usunie obszar pamieci o kluczu 1234
c) Funkcja natychmiast usunie obszar pamieci o identyfikatorze 1234
d) Funkcja oznaczy obszar pamieci o kluczu 1234 jako usuniety
>>>e) Funkcja oznaczy obszar pamieci o identyfikatorze 1234 jako usuniety

1. Chcac uzywac watkow w programie musisz dolaczyc plik naglowkowy biblioteke
>>>a) pthread
b) unixthread
c) threads
d) nie ma mozliwosci uzywaniea watkow w unixie bo nie definuje ich norma POSIX

3. MUTEX to
a) zwykla zmienna tylko nazwana inaczej ze wzgledu na zastosowanie
>>>b) rodzaj wzajemnego wykluczania (MUTual EXclusion) uzywany do synchronizacji watkow
c) rodzaj sygnalu systemowego uzywanego do synchronizacji miedzy watkami (MUlti Thread EXamination)
d) mechanizm systemowy uzywany w programach korzystajacych z watkow i wypisujacych na ekran (MultiUser TEXting)

4. Mechanizmy ktore NIE mechanizmem synchronizacji watkow to:
a) semafory
b) zmienne warunku
c) MUTEX
>>>d) pliki tymczasowe

1. Funkcja pthread_join:
a) Laczy dwa dowolne watki o ID podanych jako parametr
>>>b) Umozliwia przechwycenie wartosci zwracanej przez inny watek
>>>c) Usypia watek ja wywolujacy
>>>d) Generuje blad gdy watek poda jako argument swoj wlasny ID
>>>e) Zmusza watek do poczekania na zakonczenie innego watku

2. Ktore zdanie dotyczace funkcji pthread_exit jest nieprawdziwe:
a) Konczy dzialanie watku ktory ja wywolal.
>>>b) Jesli watek jest odlaczony wartosc zwracanabedzie pozniej dostepna dla funkcji pthread_join
c) Przyjmuje jako parametr wartosci jaka ma zostac zwrocona przez zakonczony watek
>>>d) Jesli jako drugi parametr podamy ID watku, watek ten zostanie zakonczony
>>>e) Ignoruje ona wszystkie procedury czyszczace i destruktory danych wlasnych

4. Ktore zdanie dotyczace danych wlasnych watkow jest prawdziwe:
a) Kazdy watek posiada swoj wlasny klucz do zapisu/odczytu danej
>>>b) Funkcja czyszczaca jest wywolywana bez wzgledu na to czy watek zostal anulowany czy zakonczony
c) Kazdy klucz trzeba powiazac z funkcja czyszczaca podczas jego tworzenia
d) Funkcja pthread_key_delete kasuje klucz wraz z danymi ktorych on dotyczy
e) Wywolaniesetspecific zainicjuje klucz w przypadku gdy jest on jeszcze niezainicjowany

5. Dwukrotny wywolanie pthread_mutex_lock(&moj_mutex) spowoduje:
>>>a) Dwukrotne zablokowanie muteksu typu PTHREAD_MUTEX_RECURSIVE jesli funkcje wywolal ten sam watek
>>>b) Stala blokade muteksu typu PTHREAD_MUTEX_NORMAL jesli funkcje wywolal ten sam watek
c) Blad dla kazdego rodzaju muteksu
>>>d) Chwilowe uspienie jednego watku jesli funkcje wywolaly dwa rozne watki
e) Dwukrotne zablokowanie mutksu typu PTHREAD_MUTEX_ERRORCHECK jesli funkcje wywolal ten sam watek

2. Aby usunac segment pamieci dzielonej nalezy posluzyc sie funkcja:
a) shmrmv
b) shmdel
c) shmdt
d) shmemrmv
>>>e) shmctl

3. Gdy proces przylacza segment pamieci wspolnej
>>>a) MOZE zazadac konkretnego adresu dla tego segmentu
>>>b) MOZE pozwolic systemowi wybrac adres
c) MUSI zazadac konkretnego adresu
d) MUSI pozwolic systemowi na wybranie adresu
e) sposob okreslenia adresu tego segmentu zalezy od wywolanej funkcji

5. Semafor IPC to struktura obejmujaca wlasciwie zbior semaforow.
Funkcja systemowa semop pozwala wykonac operacje na:
a) pojedynczym elemencie semafora IPC
>>> b) pojedynczym semaforze IPC
c) zbiorze (przedstawionym za pomoca tablicy) semaforow IPC
d) zwyklych zmiennych calkowitych, ktore sa "klasycznymi" semaforami tylko z punktu widzenia programisty, a nie systemu

::Zasoby IPC::Ktore z zasobow sa zasobami IPC?
>>> a) Potoki nazwane i nienazwane
>>> b) Semafory
>>> c) Kolejki komunikatow
>>> d) gniazda dziedziny Uniksa(ang.UNIX domain sockets)

::Kolejki komunikatow::Aby usunac kolejke komuniaktow nalezy?
a) uzyc funkcji int msgdel(int msqid)
b) uzyc funkcji int msgget(key_t key,int msgflg) z msglfg ustawionym na O_MQDLT
>>>c) uzyc funkcji int msgctl(int msqid,int cmd,struct msqid_ds* buf) z polem cmd ustawionym na IPC_RMID
d) uzyc funckji int msgexec(int msqid,int cmd) z polem cmd ustawionym na IPC_MSQDLT

::Tworzenie watkow::W ktorym pliku naglowkowym zadeklarowane sa funkcje obslugi watkow?
>>> a) pthread.h
b) stdio.h
c) stdlib.h
d) string.h

::Terminologia::Watek jest niekiedy nazywany:
>>> a) lekkim procesem
b) ciezkim procesem
c) grubym procesem
d) twardym procesem

::Funkcja exec::Wywolanie funkcji z rodziny exec w jednym z watkow danego procesu spowoduje:
>>> a) zakonczenie sie wszystkich watkow tego procesu
b) zakonczenie sie tylko tego jednego watku, wszystkie inne pozostana nienaruszone
>>> c) zastapienie biezacego procesu przez inny
d) wywolanie zostanie zignorowane, aby nie zniszczyc innych watkow tego procesu

::Watek odlaczony::Stworzylismy watek odlaczony. Po jego zakonczeniu:
a) ID oraz wartosc zwracana beda przechowywane do czasu, kiedy inny watek wywola funkcje pthread_join
>>> b) jest automatycznie czyszczony
c) zostanie utworzony nowy watek - kopia poprzedniego
d) zostanie odlaczone zasilanie plyty glownej

Funkcja pthread_mutex_trylock(&mut):
a) moze zablokowac dzialanie watku
>>> b) powroci od razu, jesli mutex mut jest zamkniety
>>> c) powroci od razu, jesli mutex mut jest otwarty
d) nie wykonuje absolutnie nic w systemie Linux

REKURENCYJNY mutex mut jest otwarty. Watek A wykonuje dwa razy pod rzad instrukcje: pthread_mutex_lock(&mut).
Zaden inny watek na muteksie mut w tej chwili nie operuje. Poprawne jest stwierdzenie:
a) Stan muteksu mut nie jest w tej chwili jednoznacznie okreslony
>>>b) Nie wystapi tu sytuacja zakleszczenia.
>>>c) Aby inny watek mogl zamknac mutex mut, watek A musi teraz wykonac pthread_mutex_unlock(&mut) dwukrotnie.
d) Drugie wywolanie pthread_mutex_lock(&mut) nie powiedzie sie, zostanie zwrocony blad.

::Zmienne warunkow::Wskaz stwierdzenia prawdziwe:
>>>a) Funkcja pthread_cond_broadcast wysyla informacje o zajsciu zdarzenia do wszystkich watkow oczekujacych na zajscie tego zdarzenia.
b) Funkcja pthread_cond_wait nigdy nie zablokuje dzialanie watku.
c) Zmienne warunkow sa jednym z mechanizmow synchronizacji procesow.
>>>d) Zmienne warunkow sa jednym z mechanizmow synchronizacji watkow.

O synchronizacji watkow mozna powiedziec, ze:
>>>a) Moze nieco spowolnic dzialanie programu, spowodowane wywolaniem funkcji obslugi mechanizmow synchronizacji.
b) Powinno sie jej unikac za wszelke cene w programach wielowatkowych.
>>>c) Jest mozliwa w systemie typu Linux.
>>>d) Stosowana jest w celu wyeliminowania problemow wynikajacych z jednoczesnej modyfikacji tych samych danych w roznych watkach.

Funkcja, ktora ustala rozmiar nowo utworzonego obiektu pamieci wspolnej, albo zmienia rozmiar istniejacego obiektu to:
a) shm_unlink
>>> b) ftruncate
c) fstat
d) shm_open

::Watki::Chcac uzywac watkow w programie musisz dolaczyc biblioteke
>>> a) pthread.h
b) unixthread.h
c) posixthreads.h
d) nie ma mozliwosci uzywania watkow w unixie bo nie definiuje ich norma POSIX

::Watki::Zakoczyc watek mozna uzywajac funkcji
>>> a) pthread_exit
>>> b) pthread_cancel w innym watku
c) pthread_sigmask
d) pthread_destroy

::Watki::Do tworzenia nowego watku sluzy funkcja
>>> a) pthread_create
b) pthread_join
c) pthread_equal
d) pthread_attr_init

::Watki::Sygnaly do watku wysyla sie funkcja
>>> a) pthread_kill
b) pthread_sigmask
c) send_signal
d) pthread_signal

::IPC systemu V::Zaznacz prawdziwe zdania?
>>> a) kazda kolejka ma swoj wlasny, unikalny identyfikator
>>> b) kolejka oraz zestaw semaforow moga miec taki sam identyfikator
c) funkcje rodziny get (msgget, semget, shmget) sluza jedynie do pobierania identyfikatorow instancji mechanizmow juz istniejacych w systemie
d) dana instancje mechanizmu komunikacji moze usunac jedynie proces, ktory ja utworzyl

::IPC systemu V::IPC_PRIVATE?
a) jest flaga sluzaca do tworzenia tylko instancji prywatnych, czyli np. kolejek dostepnych tylko dla danego procesu i jego potomkow
b) jest kluczem, a zatem odpowiada mu tylko jeden identyfikator
>>> c) wymusza utworzenie nowej instancji obiektu
d) wymusza utworzenie nowej instancji wtedy, gdy ustawiona jest flaga IPC_CREAT 
>>> e) moze istniec wiele mechanizmow danego typu (np. wiele zestawow semaforow) o takim kluczu

::Funkcja msgctl::Funkcja msgctl mozemy?
>>> a) zapisac prawa dostepu, informacji o uzytkowniku oraz maksymalnej pojemnosci kolejki
b) spowodowac usuniecie kolejki po tym jak wszystkie procesy oczekujace na czytanie z niej zostana obsluzone
>>> c) spowodowac natychmiastowe usuniecie kolejki
>>> d)pobrac informacje ze struktury kontrolnej msqid_ds

::Semafory::Funkcja semop?
>>> a) moze sluzyc do zmniejszania wartosci semaforow
b) nie mozna jej uzyc do zwiekszenia wartosci semafora, poniewaz za to odpowiedzialne jest jadro systemu
>>> c) moze sluzyc do zmiany wartosci jednego semafora
d) konieczne jest zamaskowanie sygnalow przed wywolaniem funkcji, gdyz operacje na wielu semaforach moga nie byc wykonane jednoczesnie

::Pamiec wspoldzielona::Segment pamieci wspoldzielonej?
a) moze byc "tylko do zapisu"
>>> b) moze byc "tylko do odczytu"
c) moze byc "tylko albo do zapisu", albo "tylko do odczytu"
>>> d) jest dziedziczony przez potomka po wywolaniu funkcji fork()
e) jest odlaczany i usuwany po wykonaniu exit()

MUTEX::Jezeli watek A zablokuje rekurencyjny MUTEX M to:
a) Ponowna proba blokady MUTEXu M przez watek A wstrzyma jego prace
>>>b) Ponowna proba blokady MUTEXu M przez watek A NIE wstrzyma jego pracy
>>>c) Proba blokady MUTEXu M przez watek B wstrzyma prace watku B
d) Proba blokady MUTEXu M przez watek B wstrzyma prace watku A

MUTEX::Funkcja pthread_mutex_trylock:
a) Probuje zablokowac watek, ktory ja wywoluje
b) Nigdy nie blokuje MUTEXu podanego w argumencie
>>>c) Nigdy nie wstrzymuje pracy watku ja wywolujacego
d) Jako drugi argument pobiera ile razy ma probowac zablokowac MUTEX

Semafory::Semafory wykorzystywane do synchronizacji watkow:
>>>a) Moga byc Semaforami standardu POSIX
b) Roznia sie od innych Semaforow tym, ze moga przyjmowac wartosci ujemne
c) Wymagaja dolaczenia do kodu programu biblioteki <semthread.h>
d) Dzialaja wylacznie w polaczeniu z MUTEXami

Semafory::Funkcja sem_wait uzyta do synchronizacji watkow:
>>>a) Dla Semafora o wartosci dodatniej, zmniejszy jego wartosc
>>>b) Zawsze przed zakonczeniem sie wykonywania zmniejszy wartosc Semafora
>>>c) Gdy wartosc Semafora wynosi 0, wstrzyma prace watku ja wywolujacego
>>>d) Niewlasciwie uzyta moze byc powodem zakleszczenia sie watkow

Zmienne warunkow::Funkcja pthread_cond_wait:
>>>a) Wstrzymuje prace watku i oczekuje na sygnal zmiany zmiennej warunku
b) Wstrzymuje prace watku w zaleznosci od spelnienia warunku dla zmiennej
>>>c) Pobiera w argumentach wskaznik na MUTEX
d) Nie wstrzyma pracy watku, ktory zablokowal wiecej niz jeden MUTEX

Funkcja pipe(int* filedes[2])
a) tworzy nazwany potok
>>>b) zwraca poprzez wektor filedes nowo utworzone deskryptory
>>>c) tworzy nienazwany potok
d) w wektorze filedes podajemy wczesniej otwarte deskryptory plikow

Potoki nienazwane
>>>a) sa jednym z mechanizmow komunkacji miedzyprocesowej
>>>b) mozemy na nie liczyc w praktycznie wszystkich wydaniach systemu UNIX
c) umozliwiaja komunikacje poprzez siec
d) sa zwiazane z plikiem na dysku

Potok nazwany mozemy utworzyc z poziomu powloki poleceniem
a) mknod
>>>b) mkfifo
c) mkpipe
d) fifocreat

Potok nazwany
>>>a) zwiazany jest z plikiem na dysku
b) umoliwia komunikacje poprzez Internet
>>>c) jest jednym z mechanizmow komunikacji miedzyprocesowej
d) dziala jak stos (kolejka LIFO)

Domyslnie potoki tworzone sa z NIE ustawionymi flagami
>>>a) O_NONBLOCK
>>>b) O_NDELAY
c) zadne z powyzszych

Powielanie deskryptorow::Ktore funkcje sluza do powielania deskryptorow?
a) dupl
>>>b) dup2
>>>c) dup
d) dpfd
e) fddp

Tworzenie potokow nienazwanych::Ktore funkcje umozliwiaja utworzenie potoku nienazwanego?
>>>a) pipe
b) mkfifo
>>>c) popen
d) mknod

Dzialanie funkcji dup2::Wywolanie funkcji:int dup2(int oldfildes, int newfiledes);...
>>>a) powoduje, ze newfiledes staje sie kopia oldfiledes, zamykajac najpierw newfiledes.
>>>b) pominie ew. komunikaty o bledach prz zamykaniu newfiledes
c) zamknie newfiledes i wypisze komuniakty o ew bledach funkcji close()
d) zastapi deskryptor oldfiledes deskryptorem newfiledes.

Potoki nazwane::Plik FIFO
a) nie ma reprezentacji w systemie plikow
>>>b) ma wlasciciela, rozmiar oraz prawa dostepu
c) mozna czytac z niego informacje z dowolnego miejsca w tym pliku
>>>d) mozna z niego czytac informacje tylko w takiej kolejnosci, w jakiej byly zapisywane

Tworzenie potokow::Wywolanie funkcji int pipe(int filedes[2])
>>>a) zwroci wartosc -1 w przypadku wystapienia bledu
>>>b) zwroci wartosc 0 gdy dperacja zakonczy sie sukcesem
>>>c) filedes[0] bedzie deskryptorem otwartym do odczytu
d) utworzy potok nazwany

::IPC Systemu V::W Systemie V wprowadzono 3 dodatkowe sposoby komunikacji miedzyprocesowej. Naleza do nich:
>>>a) kolejki komunikatow
>>>b) semafory
>>>c) pamiec wspolna
d) lacza komunikacyjne
e) synaly

::IPC Systemu V::Aby wyswietlic wszystkie zasoby IPC w systemie uzywamy komendy
>>>a) ipcs
b) ls -ipc
c) ps -ipc

::Kolejki komunikatow::Co jest niezbedne aby dzialac na kolejce komunikatow?
>>>a) liczbowy identyfikator kolejki komunikatow
>>>b) odpowiednie prawa dostepu
c) wlasna obsluga sygnalu SIGCHLD
d) nazwa kolejki komunikatow

::Semafory::Semafor to:
>>>a) licznik sluzacy do regulowania dostepu do wspolnych zasobow
b) inne okreslenie sygnalu czasu rzeczywistego
c) proces, ktory blokuje zasoby

::Pamiec wspolna::Do oblsugi pamieci wspolnej sluzy zestaw funkcji:
>>>a) shmget, shmat, shmdt, shmctl
b) semget, semop, semctl
c) msgget, msgsnd, msgrcv, msgctl

::Klucz urzadzenia IPC::Funkcja,ktora odwzorowuje nazwe sciazki pliku na klucz zasobu IPC to...
a) int ftok(const char* path, int id)
b) double ftok(char* path,key_t id)
>>> c) key_t ftok(const char* path,int id)
d) ipc_t ftok(int id,char* path)

::Kolejki komunikatow::Wywolanie msgget(key, IPC_CREAT | IPC_EXCL) zwroci?
>>>a) identyfikator kolejki,jesli kolejka nie istenieje
b) identyfikator kolejki,nawet jesli kolejka istnieje
>>> c) wartosc -1,jesli kolejka juz istnieje
d) ta funckcja nic nie zwraca

::Semafory::Wskaznik do tablicy semaforow oraz czas ostatniej zmiany znajdziemy w strukturze?
a) sembuf
b) semum
>>> c) semid_ds
d) sem_t

::Konczenie watkow::Utworzylismy nowy watek funkcja pthread_create. Gdy bedziemy chcieli zakonczyc ten watek bez konczenia procesu, mozemy w funkcji tego watku wywolac funkcje:
>>> a) return
b) escape
c) exit
>>> d) pthread_exit

::Zmienne warunkow::Wskaz stwierdzenia prawdziwe: 
>>>a) Funkcja pthread_cond_broadcast wysyla informacje o zajsciu zdarzenia do wszystkich watkow oczekujacych na zajscie tego zdarzenia.
b) Funkcja pthread_cond_wait nigdy nie zablokuje dzialanie watku.
c) Zmienne warunkow sa jednym z mechanizmow synchronizacji procesow.
>>>d) Zmienne warunkow sa jednym z mechanizmow synchronizacji watkow.

Zaznacz poprawne zdania dotyczace semaforow: 
>>> a) funkcja sem_open zwraca wskaznik semafora lub SEM_FAILED w przypadku bledu
>>> b) funkcja sem_post zwieksza wartosc semafora sem o 1 i budzi jeden z watkow oczekujacych na dodatnia wartosc semafora
c) semafor mozna usunac z pamieci niezaleznie od wartosci licznika odwolan
d) funckja sem_wait moze zwracac blad EAGAIN

1. Wskaz prawdziwe zadnia na temat potokow:
a) pojemnosc potoku jest nieograniczona
>>> b) dane zapisane do potoku na jednym jego koncu sa odczytywane na drugim koncu w takiej kolejnosci, w jakiej zostaly zapisane
c) potoki nazwane roznia sie od nienazwanych tylko tym, ze nienazwane sa uzywane dla procesow majacych wspolnych przodkow, a nazwane dla dowolnych procesow

2. W przypadku lacza od procesu potomnego do macierzystego:
a) proces macierzysty zamyka koniec lacza do odczytu
>>> b) proces macierzysty zamyka koniec lacza do zapisu
c) proces potomny zamyka koniec lacza do zapisu
>>> d) proces potomny zamyka koniec lacza do odczytu

3. Funkcja dup sluzy do:
>>> a) powielania deskryptorow plikow
b) powielania laczy komunikacyjnych
>>> c)polaczenia jednego z koncow potoku ze standardowym wyjsciem lub wejsciem procesu potomnego

5. Ktore zdania dotyczace kolejek FIFO sa poprawne?
>>>a) kolejka FIFO ma swoj typ pliku
>>>b) kolejki moga byc uzywane do komunikacji miedzy procesam macierzystym a potomnym
>>>c) kolejki moga byc uzywane do komunikacji miedzy dowolnymi procesami
d) kolejki FIFO mozna uzywac w komunikacji miedzy procesem a plikiem

O synchronizacji watkow mozna powiedziec, ze: 
>>> a) Moze nieco spowolnic dzialanie programu, spowodowane wywolaniem funkcji obslugi mechanizmow synchronizacji.
b) Powinno sie jej unikac za wszelke cene w programach wielowatkowych.
>>> c) Jest mozliwa w systemie typu Linux.
>>> d)Stosowana jest w celu wyeliminowania problemow wynikajacych z jednoczesnej modyfikacji tych samych danych w roznych watkach.

4. Funkcja mq_open:
a) W przypadku, gdy kolejka nie istnieje, zawsze wraca z bledem
b) W przypadku, gdy kolejka nie istnieje, zawsze ja tworzy
>>> c) Zwraca -1 w przypadku bledu
>>> d) Zwraca wartosc nazywana deskryptorem kolejki komunikatów
>>> e) Pozwala na ustalenie praw dostepu do kolejki uzytkownikowi, grupie i innym
f) umozliwa otwarcie kolejki tylko do odczytu, w przypadku zastosowania flagi O_WRONLY

Struktura mq_attr zawiera 
>>> a) pole mq_maxmsg, ktore okresla maksymalna liczbe komunikatow w kolejce
b) pole mq_cnt, ktore okresla liczbe komunikatow w kolejce
>>> c) pole mq_msgsize, ktore okresla maksymalny rozmiar komunikatu w bajtach
>>> d) pole mq_flags, ktore ustawione na wartosc O_NONBLOCK wlacza nieblokowanie funkcji odbioru i wysylania

::Dzialanie funkcji select::Funkcja select:
a) sluzy do zwielokrotniania wejscia-wyjscia
b) przyjmuje jako pierwszy argument (maxfdp1) maksymalna liczbe deskryptorow
c) ma 4 mozliwe wartosci powrotu
d) wraz z funkcja poll realizuje asynchroniczna forme powiadamiania

W funkcji void *mmap(void *start ,size_t lenght, int prot, int flags, int fd, off_t offset) 
>>> a) adres, pod ktory zlecamy zmapowanie pamieci start, jest tylko propozycja
b) zmapowanie pamieci odbywa sie zawsze pod podany adres start
c) argument prot z wartoscia PROT_EXEC powoduje, ze strony nie moga byc dostepne
>>> d) flaga MAP_SHARED poleca wspoldzielenie mapowania ze wszystkimi innymi procesami

::Potoki nazwane::Czy potoki nazwane:
a) sa plikami specjalnego rodzaju - nie maja nazwy w systemie plikow
>>> b) umozliwiaja komunikacje miedzy nie powiazanymi procesami
c) tworzone sa za pomoca czteroparametrowej funkcji mkfifo

::Kolejki FIFO::Czy kolejki FIFO:
>>>a) to tzw. nazwane lacza komunikacyjne
b) otwierane sa typowo z wlaczonym O_NONBLOCK
>>>c) posiadaja swoj wlasny typ pliku
>>>d) mozna stosowac do powielania strumienia wyjsciowego
e) sa jednym z kanalow IPC systemu V

::Potoki nienazwane::Czy jest prawda, ze:
>>> a) wywolanie funkcji write moze wygenerowac sygnal SIGPIPE
>>> b) sluza do komunikacji w jednym kierunku
>>> c) sluza zwykle do komunikacji miedzy procesem macierzystym i potomnym
d) po wywolaniu fork, proces macierzysty zamyka koniec do zapisu
e) po wywolaniu fork, koniec do odczytu zamykany jest przez proces potomny

::Pamiec wspólna::Wskaz prawdziwe zdanie:
>>> a) Tworzymy ja przy pomocy funkcji shm_open(const char *name, int oflag, mode_t mode)
b) Po wywolaniu funkcji shm_open nie musimy mapowac obiektu pamieci wspólnej na przestrzen adresowa w pamieci
c) moze z niej korzystac tylko jeden okreslony proces
>>> d) Aby korzystac z funkcji które ja obsluguja nalezy zainkludowac plik sys/mman.h

::IPC - System V::W strukturze shmid_ds opisujacej segment pamieci wspólnej wystepuja nastepujace pola:
>>> a) czas ostatniego odlaczenia
>>> b) identyfikator procesu ostatniej operacji
>>> c) czas ostatniego dolaczenia
>>> d) biezaca liczba dolaczen

::Sockety::Protokoly datagramowe charakteryzuja sie tym ze:
 a) Zapewniaja kontrole poprawnosci przesylanych danych
>>> b) Dane nie musza docierac do odbiorcy w tej samej kolejnosci w jakiej byly wyslane
 c) Protokól TCP jest protokolem datagramowym
>>> d) Protokól UDP jest protokolem datagramowym

::Funkcja mq_receive::Wskaz zdania prawdziwe
a) wywolanie funkcji mq_receive nigdy nie blokuje procesu
>>>b) blokowanie funkcji zalezy od parametrów okreslonych podczas tworzenia kolejki komunikatów
c) blokowanie zalezy od implementacji w danym systemie operacyjnym
d) wywolanie funkcji mq_receive zawsze blokuje proces w momencie gdy w kolejce nie ma komunikatów

::Funkcja mq_receive::Funkcja mq_receive:
a) wysyla komunikat do kolejki
>>> b) odbiera komunikat z kolejki
>>> c) zwraca liczba odebranych bajtów i -1 w przypadku bledu
d) zwraca 0 w przypadku powodzenia, -1 w przypadku bledu 

::IPC - system V:: Jaka wartosc mozna ustawic jako trzeci argument funkcji semget ?
a) IPC_PRIVATE
b) IPC_NOWAIT
c) SEM_UNDO
d) SEM_NOERROR
>>> e) IPC_CREAT

Zaznacz funkcje, które nie sluza do obslugi pamieci wspólnej POSIX:
>>> a) malloc
>>> b) shm_create
c) fstat
>>> d) realloc
e) shm_open

::IPC - system V:: Zaznacz prawdziwe zdania:
a) Funkcja shmdt sluzy do powiekszenia rozmiaru przylaczonego segmentu pamieci wspólnej
b) Ustawienie w wywolaniu shmat sygnalizatora SHM_UNDO umozliwia zapamietanie zmian zawartosci segmentu oraz przywrócenie starego stanu
>>> c) Dzieki uzyciu sygnalizatora mozna podczas wywolania shmat okreslic, czy segment ma byc dolaczony w trybie do odczytu i zapisu, czy tylko do odczytu
d) Zadna z pozostalych odpowiedzi nie jest prawdziwa
>>> e) Struktura shmid_ds zawiera m.in. informacje o biezacej liczbie dolaczen do segmentu

Co to jest POSIX?
>>> a) Standard interfejsów ulatwiajacy przenosnosc programow
b) Funkcja systemowa
c) System operacyjny
d) Definuje zalecany sposób wzajemnego oddzialywania aplikacji i systemu operacyjnego

10 Po wywolaniu funkcji int shm_unlink (const char * name):
 a) Obiekt zostanie usuniety bez wzgledu na liczbe odwolan do niego
 b) Zostana zamkniete wszystkie odwolania do obiektu wskazywanego przez name, a obiekt pozostanie w pamieci
 c) Obiekt zostanie natychmiast usuniety, jesli ta funkcje wywola proces który utworzyl pamiec (bez wzgledu czy istnieja inne odwolania do tej pamieci)
>>> d) Obiekt zostanie usuniety gdy liczba odwolan do niego wyniesie zero 

13 Semafory nazwane tworzymy za pomoca funkcji:
a) sem_create
b) sem_createnamed
c) sem_init
>>> d) sem_open

::IPC - system V:: Do ustawienia wartosci poczatkowych semaforom sluzy funkcja:
a) semset
b) semmk
>>> c) semctl
d) semadd
e) seminit

::IPC - system V:: Które z ponizszych zdan sa prawdziwe?
a) funkcja ftok generuje klucz tylko na podstawie nazwy sciezki podanej jako parametr
>>> b) funkcja ftok generuje klucz na podstawie nazwy sciezki oraz identyfikatora projektu podanych jako parametry
>>> c) sciezka podana jako parametr funkcji ftok musi sie odnosic do istniejacego pliku
d) funkcja ftok przy kazdym wywolaniu z tymi samymi parametrami zwróci inny klucz

::IPC - system V:: Efektem dzialania funkcji msgctl jest:
>>> a) pobranie struktury msqid_ds opisujacej kolejke komunikatów jesli argument cmd ma wartosc IPC_STAT
b) utworzenie/dowiazanie do kolejki, jesli argument ma wartosc IPC_CREAT
>>> c) usuniecie kolejki z systemu, jesli argument ma wartosc IPC_RMID
d) zadne z pozostalych zdan nie jest prawdziwe

::Funkcja mq_close::
a) Jeden z jej parametrów okresla, czy ma zamknac czy usunac kolejke
b) Sluzy do usuwania kolejki komunikatów z systemu
>>> c) Sluzy do zamkniecia kolejki komunikatów bez jej usuwania
d) Nie jest funkcja systemu POSIX

::IPC - system V:: Funkcja ftok zwraca:
a) adres nowo utworzonego segmentu pamieci wspólnej
b) deskryptor pliku dla sciezki bedacej argumentem funkcji
c) identyfikator kolejki komunikatów
>>> d) klucz zasobu powiazany z podana sciezka i numerem

4. Wskaz zdania charakteryzujace uzycie flagi IPC_STAT w funkcji msgctl:
a) umozliwia zmiane id uzytkownika, który stworzyl strukture
b) umozliwia zmiane gid uzytkownika, który stworzyl strukture
>>> c) zadna odpowiedz nie jest poprawna
d) umozliwia zmiane id uzytkownika, który ostatnio korzystal ze struktury 

9. Dostep do struktury IPC ma:
a) kazdy proces
b) zalezy to od implementacji systemu
>>> c) proces który ja utworzyl i jego potomkowie
>>> d) atrybuty dostepu mozna ustalic podczas tworzenia struktury

Ktora z funkcji mozemy ustawic flage S_NONBLOCK dla pliku?
>>> a) fcntl()
b) fopen()
c) fstat()
d) open()

::Potoki::Funkcja systemowa: int pipe(int filedes [2]);
a) powinna byc wywolana przed fork jesli chcemy, aby proces potomny odziedziczyl deskryptory plików procesu rodzica,
b) powoduje zamkniecie deskryptorów z których dany proces nie korzysta
c) tworzy proces potomny,
>>> d) tworzy potok, który ma systemowo ograniczona wielkosc (rózna w zaleznosci od wersji systemu)

::IPC - system V:: Zaznacz prawdziwe zdania:
a) Zadna z pozostalych odpowiedzi nie jest prawdziwa
b) Funkcja shmget tworzy segment pamieci wspólnej i dolacza go do przestrzeni adresowej procesu wywolujacego
c) Funkcja shmdt sluzy do dolaczenia istniejacego segmentu pamieci wspólnej do przestrzeni adresowej procesu
>>> d) Przy uzyciu funkcji shmctl mozna miedzy innymi usunac z systemu segment pamieci wspólnej lub tez, w przypadku bycia nadzorca systemu, zaryglowac lub odryglowac segment pamieci wspólnej
>>> e) Funkcja shmat zwraca wskaznik do segmentu pamieci wspólnej, jesli operacja zakonczyla sie sukcesem

::IPC - system V:: Podniesienie opuszczonego semafora jest mozliwe:
a) jedynie przez proces, który utworzyl dany semafor funkcja semget 	
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora 	
>>> c) przez kazdy proces majacy dostep do danego semafora 	

Do tworzenia potoków nazwanych z linii polecen (z poziomu powloki) uzywamy polecenia:
a) FIFO_t 	
>>> b) mkfifo 	
c) makepipe 	
d) pipepipe 	
e) pipemake

::IPC - system V:: Zaznacz zdania falszywe:
a) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej ale ich nie zwalnia 	
b) Wykonujac polecenie ipcs z flaga -m mozna uzyskac informacje o segmentach pamieci wspóldzielonej w systemie 	
>>> c) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej od przestrzeni adresowej tego procesu oraz usuwa segmenty z systemu 	
d) Uzycie jako parametru wywolania shmctl stalej IPC_STAT oraz przekazanie wskaznika do struktury shmid_ds umozliwia pobranie informacji o segmencie 	

Poprawna pod wzgledem standardu inicjalizacja muteksu ma postac:
1) pthread_mutex_t mut;
   pthread_mutex_init(&mutex, NULL);
2) pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
3) pthread_mutex_t mut = NULL;
4) pthread_mutex_t mut = malloc(sizeof(pthread_mutex_t));
a) Odpowiedz 3 jest poprawna   
b) Odpowiedz 4 jest poprawna   
>>>c) Odpowiedz 2 jest poprawna   
>>>d) Odpowiedz 1 jest poprawna   

Przesylanie danych przez gniazdo w trybie connection-oriented (SOCK_STREAM) w domenie Internet:
>>> a) Powoduje, ze u odbiorcy dostajemy ten sam ciag bajtów, który wyslalismy   
b) Moze doprowadzic do blednej interpretacji liczb u odbiorcy (o ile nie zabezpieczymy sie przed tym)   
c) Wymaga dopisywania do przesylanych danych naglówka warstwy transportu (numery segmentów, flagi protokolu TCP itd))   
>>> d) Wymaga istniejacego polaczenia pomiedzy gniazdami nadawcy i odbiorcy   
e) Jest mozliwe tylko wtedy, gdy gniazdo odbiorcy znajduje sie na innym komputerze   

W jaki sposób mozna umozliwic dostep do semafora POSIXowego dla róznych procesów
a) Semafory moga byc dostepne tylko w jednym procesie, gdyz sluza do synchronizacji watków 	
b) Przy zmianie ustawien semafora (funkcja sem_setproperty) 	
>>> c) Przy inicjalizacji semafora (funkcja sem_init) 	

::IPC - system V::Zaznacz prawdziwe zdania z nastepujacych:
a) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipc 	
b) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipcls 	
>>> c) do usuniecia zasobu IPC systemu V sluzy polecenie ipcrm 	
d) do usuniecia zasobu IPC systemu V sluzy polecenie rmipc 	

::IPC - system V:: Pojedyncze wywolanie funkcji msgrcv umozliwia odczytanie z kolejki komunikatów:
>>> a) pierwszego umieszczonego w niej komunikat (kolejka FIFO) 	
b) ostatnio umieszczonego w niej komunikatu, którego typ nie przekracza wartosci bezwzglednej parametru okreslonego w wywolaniu 	
c) ostatnio umieszczonego w niej komunikatu (kolejka LIFO) 	
d) ostatnio umieszczonego w niej komunikatu o okreslonym w wywolaniu typie 	
>>> e) pierwszego komunikatu o okreslonym w wywolaniu typie

Czy przez ponizsze deklaracje zostanie w programie wyrzucony blad?:
...
int tab[2];
...
if(pipe(tab, STDIN) < 0)
...

>>> a) tak, poniewaz w pipe drugiego argumentu nie powinno w ogóle nie byc 	
b) tak, poniewaz w pipe nie powinno byc wogole pierwszego argumentu 	
c) tak, poniewaz w pipe pierwszym argumentem powinno byc tab[0] 	
d) tak, poniewaz tablica powinna byc typu pid_t a nie int 	
e) nie

Chcac uzywac watków w programie trzeba dolaczyc biblioteke:
a) posixthreads
>>>b) pthread
c) unixthread
d) nie ma mozliwosci uzywania watkow w unixie bo nie definiuje ich norma POSIX

Adres IPv4 petli zwrotnej polaczen sieciowych (tzw loopback) to:?
a) 255.0.0.255
b) 127.0.0.255
>>>c) 127.0.0.1
d) 127.0.0.0
e) 0.0.0.0

(IPC - system V) W kolejce komunikatów umieszczono w podanej kolejnosci nastepujace wiadomosci:
1. 'Ala ma kota' -- typ 10
2. 'Ela ma psa' -- typ 5
3. 'Ola ma rybki' -- typ 15
O której z pan odczytamy informacje, jesli w wywolaniu funkcji msgrcv jako argument dotyczacy typu podamy wartosc -12 ?
Wybierz co najmniej jedna odpowiedz
a) o Oli
>>> b) o Eli
c) o zadnej z nich; funkcja zwróci -1 gdyz w kolejce nie wystepuje komunikat o podanym typie
d) o Ali

(IPC - system V) Do metod komunikacji miedzyprocesowej IPC Systemu V naleza:
>>>a) kolejki komunikatów, semafory, pamiec dzielona
b) kolejki komunikatów, pamiec dzielona, ryglowania rekordów
c) kolejki komunikatów, potoki, pamiec dzielona
d) wszystkie mechanizmy komunikacji miedzyprocesowej w Systemach UNIX V
e) potoki, ryglowanie rekordów, pamiec dzielona

Które funkcje powduja calkowite usuniecie kolejki Posix z systemu?
a) int mq_close(mqd_t mqdes);
>>>b) int mq_unlink(const char *name);
c) int mq_delete(mqd_t mqdes);
d) int mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr) z odpowiednimi atrybutami
e) int mq_remove(mqd_t mqdes);

(IPC - system V) W strukturze shmid_ds opisujacej segment pamieci wspólnej wystepuja nastepujace pola:
>>>a) czas ostatniego dolaczenia
>>>b) czas ostatniego odlaczenia
>>>c) identyfikator procesu ostatniej operacji
>>>d) biezaca liczba dolaczen

Nazwy obiektów POSIX
a) Moga miec dlugosc co najwyzej 8 znaków
b) Moga byc dowolnymi ciagami znaków
c) Maja postac nazwy pliku, przy czym nie musi on istniec w systemie
>>> d) Maja postac nazwy pliku, przy czym musi on istniec w systemie
e) Sa identyfikatorami calkowitoliczbowymi

(IPC - system V) Próba opuszczenia semafora o wartosci 0 powoduje:
a) zakonczenie procesu, który próbuje opuscic semafor
b) nic sie nie stanie
c) zwrócenie bledu przez funkcje semop
>>>d) uspienie procesu, który próbuje opuscic semafor

Funkcja sem_open:: Wybierz co najmniej jedna odpowiedz
>>>a) W przypadku istnienia semafora o podanej nazwie, otwiera go zamiast tworzyc (gdy nie ma ustawione flagi O_EXCL)
b) Zwraca identyfikator semafora jako wartosc typu int
>>>c) Sluzy do tworzenia semafora POSIX
d) Sluzy do tworzenia semafora IPC V

Jesli deskryptor pliku, który reprezentuje koniec potoku otwarty do zapisu zostaje zamkniety to:
a) Jesli nie istnieja zadne inne procesy majace otwarty potok do zapisu, to do procesow majacych otwarty deskryptor tego potoku do odczytu zostaje wyslany sygnal SIGPIPE
>>>b) Jesli nie istnieja zadne inne procesy majace otwarty potok do zapisu, to wszystkie procesy, które w uspieniu czekaly na odczyt z pustego potoku zostaja obudzone, a ich funkcje read zwracaja 0
>>>c) Jesli istnieja inne procesy, które nadal maja otwarty potok do zapisu, to nic sie nie dzieje
>>>d) Jesli nie istnieja zadne inne procesy majace otwarty potok do zapisu, a potok jest pusty, to proces probujacy czytac dane z potoku zachowuje sie podobnie jak proces napotykajacy koniec pliku podczas odczytywania danych z pliku.

Czym róznia sie watki poziomu uzytkownika od watków poziomu jadra
a) W przypadku watków poziomu uzytkownika zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
>>>b) Szybciej odbywa sie przelaczanie miedzy watkami poziomu uzytkownika
>>>c) Watki poziomu jadra sa obslugiwane jaka pracujace w obrebie tej samej przestrzeni adresowej procesy.
>>>d) W przypadku watków poziomu jadra zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
e) Szybciej odbywa sie przelaczanie miedzy watkami poziomu jadra

Zalózmy, ze nasz program przeprowadza dzialania, które moga zmienic warunek chroniony zmienna warunku.
W jakiej kolejnosci powinny zostac wykonane ponizsze czynnosci:
1. odblokowanie muteksu towarzyszacego zmiennej warunku.
2. zmiana warunku,
3. zablokowanie muteksu towarzyszacego zmiennej warunku,
4. sygnalizacja zmiennej warunku

a) 1,2,3,4
b) 3,2,4,1
c) 2,1,4,3
>>>d) 3,2,1,4

Która z funkcji mozemy ustawic flage S_NONBLOCK dla pliku:
>>>a) open()   
>>>b) fcntl()   
c) fopen()   
d) fstat()   

Podczas mapowania pamieci wspólnej argument prot pozwala na:
>>>a) Zamapowanie pamieci w trybie do wykonania   
>>>b) Zablokowanie dostepu przez inne procesy do pamieci wspólnej   
c) Podanie ID uzytkownika, który moze miec dostep do pamieci (8 najstarszych bitów)   
>>>d) Zablokowanie odczytu z zamapowanej pamieci   

(IPC - system V) Wywolanie funkcji msgctl (semctl, shmctl) ze stala IPC_SET pozwala w pewnych sytuacjach na:
a) zadna z pozostalych odpowiedzi nie jest prawdziwa   
b) zmiane identyfikatora grupy twórcy   
>>>c) zmiane identyfikatora grupy wlasciciela   
d) zmiane identyfikatora uzytkownika twórcy   
>>>e) zmiane identyfikatora uzytkownika wlasciciela   

Stworzenie soketu z PF_INET6 jako rodzina protokolu komunikacji:
>>>a) jest poprawne   
>>>b) tworzy nam lacze korzystajac z IPv6   
c) umozliwa komunikacje za pomoca IPv6 oraz IPv4   
d) tworzy lacze strumieniowe   
e) tworzy lacze lokalne   
f. tworzy lacze AppleTalk   

Funkcja mq_close) Wybierz co najmniej jedna odpowiedz
a) Jeden z jej parametrów okresla, czy ma zamknac czy usunac kolejke   
>>>b) Sluzy do zamkniecia kolejki komunikatów bez jej usuwania   
c) Nie jest funkcja systemu POSIX   
d) Sluzy do usuwania kolejki komunikatów z systemu   

Utworzylismy nowy watek funkcja pthread_create) Gdy bedziemy chcieli zakonczyc ten watek bez konczenia procesu, mozemy w funkcji tego watku wywolac instrukcje lub funkcje:
a) escape   
>>>b) pthread_exit   
>>>c) return w glównej funkcji watku   
d) exit   

(IPC - system V) Do pobrania komunikatu z kolejki sluzy funkcja:
>>>a) msgrcv   
b) getmsg   
c) msgctl   
d) msgget   

Funkcja sem_wait(sem_t *sem):
a) Zwieksza wartosc semafora   
>>>b) Zmniejsza wartosc semafora   
c) Zawiesza watek, az semafor stanie sie zerowy   
>>>d) Zawiesza watek, az semafor stanie sie niezerowy   

(IPC - system V) Podniesienie opuszczonego semafora jest mozliwe:
>>>a) przez kazdy proces majacy dostep do danego semafora   
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora   
c) jedynie przez proces, który utworzyl dany semafor funkcja semget   

Co sie stanie, jesli bedziemy chcieli zapisac przy pomocy funkcji write() do niepelnej kolejki wiecej danych, niz jest ona w stanie pomiescic ?
a) zostanie wyslany sygnal SIGPIPE   
b) zawsze udaje sie wyslac dane bez blokowania, gdyz kolejka posiada dynamicznie powiekszany bufor   
>>>c) jesli flaga S_NONBLOCK jest ustawiona, a rozmiar przesylanych danych jest wiekszy niz PIPE_BUF, funkcja zwróci 0   
>>>d) jesli flaga S_NONBLOCK nie jest ustawiona to proces zapisujacy dane w momencie wypelnienia kolejki zostaje uspiony   

Poprawna sekwencja wywolan po stronie serwera, prowadzaca do akceptacji polacznia od klienta w strumieniowym trybie komunikacji (SOCK_STREAM):
a) socket, listen, accept, bind   
b) listen, socket, bind, accept   
>>> c) socket, bind, listen, accept   
d) bind, socket, accept, listen   

Wskaz stwierdzenia prawdziwe:
>>>a) Zmienne warunków sa jednym z mechanizmów synchronizacji watków.   
>>>b) Funkcja pthread_cond_broadcast wysyla informacje o zajsciu zdarzenia do wszystkich watków oczekujacych na zajscie tego zdarzenia)   
c) Zmienne warunków sa jednym z mechanizmów synchronizacji procesów.   
d) Funkcja pthread_cond_wait nigdy nie zablokuje dzialania watku.   

Czym róznia sie watki poziomu uzytkownika od watków poziomu jadra
a) Szybciej odbywa sie przelaczanie miedzy watkami poziomu jadra   
>>>b) W przypadku watków poziomu jadra zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom   
>>>c) Szybciej odbywa sie przelaczanie miedzy watkami poziomu uzytkownika   
>>>d) Watki poziomu jadra sa obslugiwane jaka pracujace w obrebie tej samej przestrzeni adresowej procesy.   
e) W przypadku watków poziomu uzytkownika zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom   

(IPC - system V) Usuniecie segmentu pamieci wspólnej po wywolaniu funkcji shmctl ze stala IPC_RMID nastepuje:
a) zawsze natychmiast   
>>>b) dopiero gdy nie bedzie procesu, który mialby dolaczony ten segment do swojej przestrzeni adresowej   
c) natychmiast gdy jest ono realizowane przez proces z uprawnieniami nadzorcy   
d) w sytuacji gdy inne procesy korzystaja z tego segmentu natychmiast tylko gdy podamy flage SHM_NOERROR   

Które funkcje powduja calkowite usuniecie kolejki Posix z systemu?
a) int mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr) z odpowiednimi atrybutami   
>>>b) int mq_unlink(const char *name);   
c) int mq_close(mqd_t mqdes);   
d) int mq_remove(mqd_t mqdes);   
e) int mq_delete(mqd_t mqdes);   

Podajac adres do komunikacji nalezy pamietac o tym ze:
a) nie moze on byc adresem z sieci lokalnej   
b) nie mozna go uzywac wielokrotnie   
>>>c) mozna go pobrac z adresu np. www.agh.edu.pl za pomoca funkcji gethostbyname   
>>>d) mozna go pobrac z adresu w formie ip (np. 149.156.96.9) za pomoca funkcji inet_aton   
>>>e) moga wystepowac rózne sposoby zapisu danych binarnych i nalezy sie upewnic ze podawany adres jest w postaci uzywanej w sieci   

(IPC - system V) Podniesienie opuszczonego semafora jest mozliwe:
a) jedynie przez proces, który utworzyl dany semafor funkcja semget   
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora   
>>>c) przez kazdy proces majacy dostep do danego semafora   

Pamiec wspólna) Wskaz prawdziwe zdanie:
a) Moze z niej korzystac tylko jeden okreslony proces   
>>>b) Aby korzystac z funkcji ktore ja obsluguja nalezy zainkludowac plik sys/mman.h   
>>>c) Tworzymy ja przy pomocy funkcji shm_open(const char *name, int oflag, mode_t mode)   
d) Po wywolaniu funkcji shm_open nie musimy mapowac objektu pamieci wspolnej na przestrzen adresowa w pamieci   

Do tworzenia potoków nazwanych z linii polecen (z poziomu powloki) uzywamy polecenia:
a) FIFO_t   
>>>b) mkfifo   
c) makepipe   
d) pipepipe   
e) pipemake   

(IPC - system V) Zaznacz zdania falszywe:
a) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej ale ich nie zwalnia   
b) Wykonujac polecenie ipcs z flaga -m mozna uzyskac informacje o segmentach pamieci wspóldzielonej w systemie   
>>>c) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej od przestrzeni adresowej tego procesu oraz usuwa segmenty z systemu   
d) Uzycie jako parametru wywolania shmctl stalej IPC_STAT oraz przekazanie wskaznika do struktury shmid_ds umozliwia pobranie informacji o segmencie   

Co to jest POSIX?
a) Definuje zalecany sposób wzajemnego oddzialywania aplikacji i systemu operacyjnego   
>>>b) Standard interfejsów ulatwiajacy przenosnosc programów   
c) Funkcja systemowa   
d) System operacyjny   

Watki nalezace do tego samego procesu
a) Otrzymuja kopie wszystkich zasobów systemowych procesu nadrzednego   
>>>b) Kazdy z watków posiada wlasny niezalezny stos.   
>>>c) Zasoby systemowe procesu sa dzielone miedzy jego watki.   
d) Wspóldziela ze soba stos procesu nadrzednego.   
>>>e) Moga posiadac dane prywatne skojarzone z pewnymi kluczami dostepne tylko w watku, który dokanal takiego skojarzenia   

Chcac uzywac watków w programie trzeba dolaczyc biblioteke:
a) unixthread   
b) posixthreads   
c) nie ma mozliwosci uzywania watkow w unixie bo nie definiuje ich norma POSIX   
>>>d) pthread   

(IPC - system V) Pojedyncze wywolanie funkcji msgrcv umozliwia odczytanie z kolejki komunikatów:
>>>a) pierwszego umieszczonego w niej komunikat (kolejka FIFO)   
b) ostatnio umieszczonego w niej komunikatu, którego typ nie przekracza wartosci bezwzglednej parametru okreslonego w wywolaniu   
c) ostatnio umieszczonego w niej komunikatu (kolejka LIFO)   
d) ostatnio umieszczonego w niej komunikatu o okreslonym w wywolaniu typie   
>>>e) pierwszego komunikatu o okreslonym w wywolaniu typie   

Czy przez ponizsze deklaracje zostanie w programie wyrzucony blad?:
...
int tab[2];
...
if(pipe(tab, STDIN) < 0)
...
>>>a) tak, poniewaz w pipe drugiego argumentu nie powinno w ogóle nie byc   
b) tak, poniewaz w pipe nie powinno byc wogole pierwszego argumentu   
c) tak, poniewaz w pipe pierwszym argumentem powinno byc tab[0]   
d) tak, poniewaz tablica powinna byc typu pid_t a nie int   
e) nie   
 
 1. Kazdy komunikat w kolejce komunikatów POSIX zawiera:
>>>a) Rozmiar obszaru danych
>>>b) Dane komunikatu
>>>c) Priorytet komunikatu
d) Identyfikato watka, który wyslal komunikat
e) Identyfikator procesu, który wyslal komunikat

2. Do zwolnienia bloku pamieci wspólnej POSIX sluzy funkcja:
a) Pamiec nie moze byc zwalniana recznie) Zwalnia ja system operacyjny po zakonczeniu procesów, które sie do niej odwoluja
b) close
c) shm_delete
d) unlink
>>>e) shm_unlink
f. shm_close

3. Funkcja sem_wait(sem_t *sem):
>>>a) Zawiesza watek, az semafor stanie sie niezerowy
>>>b) Zmniejsza wartosc semafora
c) Zwieksza wartosc semafora
d) Zawiesza watek, az semafor stanie sie zerowy

4. Do obiektów IPC POSIX stworzonych przy uzyciu mq_open sem_open shm_open maja dostep (Wskaz zdania prawdziwe):
>>>a) Zalezne jest to od uprawnien nadanych obiektowi IPC
>>>b) Proces "rodzic" oraz procesy potomne
c) Zalezy od implementacji w systemie
d) Wszytkie procesy

5. W przypadku sukcesu funkcja pipe:
>>>a) zwraca wartosc 0
>>>b) zmienia wartosci elementów tablicy calkowitoliczbowej podanej jej jako parametr
c) laczy standardowe wyjscie programu (stdout) z plikiem bedacym jej argumentem
d) zwraca wartosc -1
e) tworzy potok nazwany

6. Pojedyncze wywolanie funkcji msgrcv umozliwia odczytanie z kolejki komunikatów:
a) ostatnio umieszczonego w niej komunikatu o okreslonym w wywolaniu typie
>>>b) pierwszego komunikatu o okreslonym w wywolaniu typie
>>>c) pierwszego umieszczonego w niej komunikat (kolejka FIFO)
d) ostatnio umieszczonego w niej komunikatu (kolejka LIFO)
e) ostatnio umieszczonego w niej komunikatu, którego typ nie przekracza wartosci bezwzglednej parametru okreslonego w wywolaniu

7. Obsluga sygnalow w watku przedstawia sie nastepujaco :
a) dla kazdego watku nalezy wywolac procedure signal , gdyz watek nie dziedziczy ustawien sygnalów po watku glównym
>>>b) Kazdy watek moze miec odrebna maske blokowania sygnalów
>>>c) Wszystkie watki w jednym procesie wspóldziela procedury obslugi sygnalów, domyslnie ustawione przez programiste
d) W systemie Linux nie ma mozliwosci wysylania komunikatów pomiedzy watkami, adresowanych do konkretnego watku.

8. Utworzylismy nowy watek funkcja pthread_create) Gdy bedziemy chcieli zakonczyc ten watek bez konczenia procesu, mozemy w funkcji tego watku wywolac instrukcje lub funkcje:
a) escape
b) exit
>>>c) pthread_exit
>>>d) return w glównej funkcji watku

9. Wskaz takie zestawy funkcji wejscia/wyjscia w których choc jedna zawsze NIE spelni swojego zadania, jesli wywolana zostanie dla potoku nazwanego:
a) write, read, open
>>>b) lseek, write, open
c) write, read, close
>>>d) read, write, lseek
>>>e) lseek, close, open

10. Mutex typu PTHREAD_MUTEX_RECURSIVE_NP ma nastepujace cechy?
>>>a) Watek, który zablokowal mutex, moze zwiekszyc licznik blokad mutexu
b) Mutex zawsze odblokowujemy tylko raz
c) Zadna z pozostalych odpowiedzi nie jest prawdziwa
d) Kazdy watek moze zwiekszyc licznik blokad mutexu

11. Korzystanie z protokolu TCP przy gniazdach:
a) jest niemozliwe
b) jest mozliwe w dziedzinie Unixa w trybie connection-oriented (SOCK_STREAM)
c) jest mozliwe w dziedzinie Internetu w trybie connectionless (SOCK_DGRAM)
>>>d) jest mozliwe w dziedzinie Internetu w trybie connection-oriented (SOCK_STREAM)
>>>e) TCP jest domyslnym protokolem dla odpowiedniej pary dziedzina - tryb komunikacji

12. Kazdy program dzialajacy jako serwer musi w swoim kodzie miec wywolanie funkcji?
>>>a) bind(...)
b) connect(...)
>>>c) listen(...)
>>>d) socket(...)
e) setsockopt(...)
>>>f. accept(...)

13. (IPC - system V) Jaka wartosc mozna ustawic jako trzeci argument funkcji semget ?
a) SEM_NOERROR
b) SEM_UNDO
c) IPC_PRIVATE
d) IPC_NOWAIT
>>>e) IPC_CREATE

14. (IPC - system V) Zaznacz prawdziwe zdania z nastepujacych:
a) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipcls
b) do usuniecia zasobu IPC systemu V sluzy polecenie rmipc
>>>c) do usuniecia zasobu IPC systemu V sluzy polecenie ipcrm
d) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipc

15. (IPC - system V) Zaznacz prawdziwe zdania:
>>> a) Funkcja shmat zwraca wskaznik do segmentu pamieci wspólnej, jesli operacja zakonczyla sie sukcesem
b) Funkcja shmget tworzy segment pamieci wspólnej i dolacza go do przestrzeni adresowej procesu wywolujacego
c) Zadna z pozostalych odpowiedzi nie jest prawdziwa
>>> d) Przy uzyciu funkcji shmctl mozna miedzy innymi usunac z systemu segment pamieci wspólnej lub tez, w przypadku bycia nadzorca systemu, zaryglowac lub odryglowac segment pamieci wspólnej
e) Funkcja shmdt sluzy do dolaczenia istniejacego segmentu pamieci wspólnej do przestrzeni adresowej procesu 

Proba czytania z potoku wiekszej liczby bajtow niz sie w nim aktualnie znajduje w momencie gdy koniec do zapisu jest zamkniety spowoduje:   
a) natychmiastowy powrot funkcji read z wartoscia 0
b) oczekiwanie w funkcji read jesli flaga O_NONBLOCK jest ustawiona
>>>c) przeczytanie dostepnej liczby bajtow oraz zwrocenie przez funkcje read liczby bajtow przeczytanych
d) oczekiwanie w funkcji read jesli flaga O_NONBLOCK nie jest ustawiona

MUTEXy dzielimy na:
>>> a) Szybkie
b) Wielowatkowe (moze wejsc wiecej niz jeden watek)
>>> c) Rekurencyjne
>>> d) Sprawdzajace bledy

::IPC - system V::Zaznacz prawdziwe zdania:
a) Jezeli wywolujac funkcje semop bedziemy alokowac zasoby (wartosc sem_op ujemna) i jezeli ustawimy sygnalizator SEM_UNDO, to jezeli zasób nie zostanie zwolniony w ciagu zadanego przedzialu czasu, to jadro zwolni go automatycznie
>>> b) Jezeli wywolujac funkcje semop bedziemy alokowac zasoby (wartosc sem_op ujemna) i jezeli ustawimy sygnalizator SEM_UNDO, to jadro bedzie pamietac, ile zasobów zajelismy dla danego semafora i w momencie wykonania exit przez proces jadro sprawdzi, czy istnieja nie zastosowane wartosci nastawiajace dla tego semafora i w razie potrzeby dokona wyrównania wartosci semafora
>>> c) Funkcja semop realizuje w sposób atomowy operacje na zbiorze semaforów tzn. albo zostana wykonane wszystkie zadane operacje, albo zadna
d) Operacja wykonywana przez funkcje semop moze zmienic stan co najwyzej jednego semafora ze zbioru
e) Zadne z pozostalych zdan nie jest prawdziwe 

::Watki::Funkcja pthread_cleanup_push:
>>> a) rejestruje funkcje, która jest wywolana jak watek wywola funkcje pthread_exit
b) usuwa funkcje ze zbioru funkcji czyszczacych watku
c) blokuje proces
d) rejestruje funkcje na stosie

Przy tworzeniu/otwarcia obiektu pamieci wspólnej POSIX (shm_open) mozemy podac nastepujace flagi:
>>> a) O_RDONLY - pamiec tylko do odczytu
b) O_WRONLY - pamiec tylko do zapisu
>>> c) O_RDWR - pamiec do odczytu i zapisu
d) Zadne z przedstawionych. Pamiec dzielona jest zawsze do odczytu i zapisu 

Które zdania dotyczace kolejek FIFO sa prawdziwe?
a) ilosc danych, które mozna zapisac do kolejki FIFO jest ograniczona jedynie rozmiarem przestrzeni dyskowej
b) kolejki moga byc uzywane jedynie do komunikacji miedzy procesami spokrewnionymi
>>> c) kolejka FIFO jest reprezentowana w systemie przez plik odpowiedniego typu
>>> d) aby móc korzystac z utworzonej kolejki FIFO (poprzez funkcje mkfifo) trzeba ja otworzyc wywolujac funkcje open
