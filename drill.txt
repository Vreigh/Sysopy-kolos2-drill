Która z niżej wymienionych funkcji umożliwia ograniczone oczekiwanie na warunek? Wybierz jedną lub więcej:
a) żadana z wymienionych w innych punktach
b) int sem_wait(sem_t* sem)
c) int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex)
>>>d) int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, struct timespec* abstime)

(IPC - system V). Wywołanie:
msgrcv(id, (struct msgbuf*) & data, 3, 4, IPC_NOWAIT | MSG_NOERROR);
a) Zapisze komunikat typu 3 do struktury data
b) Jeśli nie ma aktualnie dostępnego komunikatu zadanego typu, funkcja nie zablokuje procesu ale i nie zwróci błędu
>>>c) Zapisze komunikat typu 4 do struktury data
>>>d) Funkcja skróci komunikat gdy będzie on dłuższy od wartości odpowiedniego argumentu
e) Ma błędnie ustawione flagi

Dla funkcji sem_getvalue prawdziwe są następujące zdania:
>>>a) bieżąca wartość semafora jest przekazywana w drugim argumencie funkcji
b) bieżąca wartość semafora jest wartością zwracaną przez funkcję 
c) odczytana przez funkcję bieżąca wartość semafora jest zawsze ujemna
d) funkcję tą można uzywać tylko dla semaforów nazwanych
>>>e) odczytana przez funkcję bieżąca wartość semafora może byćujemna
f) funkcję tą można używać tylko dla semaforów nienazwanych

Wykorzystanie sygnalizatora IPC_EXCL w wywołaniu funkcji msgget(semget, shmget):
a) ma sens tylko przy jednoczeesnym stosowaniu klucza IPC_PRIVATE
b) powoduje że funkcja ta kończy się błędem gdy zasób o podanym kluczu nie był jeszcze utworzony
>>>c) żadna z pozostałych odpowiedzi nie jest prawdziwa
d) zapewnia, że nowo utworzony zasób będzie mógł być wyłącznie używany przez proces, który go utworzył

Wskaż prawdziwe zdania dla funkcji munmap dla pamięci wspólnej POSIX:
>>>a) Po wywołaniu munmap odwołania do obszaru pamięci przestają być poprawne
b) Powoduje usunięcie obiektu pamięci wspólnej 
c) Nie ma wpływu na usunięcie obiektu pamięci wspólnej z systemu
d) Nie jest to poprawna funkcja POSIX
>>>e) Po odmapowaniu wszystkich dostępów do pamięci wspólnej, jest usuwana

Które z poniższych pól występują w strukturze 'IPC_PERM'?
a) kolejny numer obiektu
>>b) prawa dostępu
c) czas utworzenia zasobu
>>>d) identyfikator twórcy zasobu

Maksymalną dozwoloną liczbę bajtów w kolejce przy pomocy funkcji msgctl może zwiększyć:
>>>a) właściciel kolejki
b) nie jest możliwa taka operacja
>>>c) nadzorca systemu
>>>d) twórca kolejki

Które zdania opisują różnice pomiędzy funkcjami sem_wait i sem_trywait
a) Funkcja sem_wait nie można wykonywać dla semaforów nienazwanych, a sem_trywait można
b) Funkcja sem_wait zmniejsza wartość semafora o 1, a sem_trywait nie zmienia wartości semafora
>>>c) Gdy semafor jest zablokowany, funkcja sem_wait usypia proces, aż semafor zostanie odblokowany, natomiast w takiej sytuacji sem_trywait od razu kończy swoje działanie

Numery portów?
>>>a) Numer portu jest 16-bitową liczbą
b) Numer portu jest 32-bitową liczbą
>>>c) Zarezerwowane numery portów to 0..1023
d) Zarezerwowane numery portów to 0..1024
e) Zarezerwowane numery portót to 0..65535

Do pobrania właściwości kolejki komunikatów służy funkcja:
a) msgsnd
>>>b) msgctl
c) msgstat
d) msgget

Wskaż zdanie lub zdania prawdziwe:
a) Gniazda domeny PF_INET służą do obsługi protokołu IPv6
b) Po zaakceptowaniu połączenia funkcją accept, do obsługi tego połączenia stosuje się to samo gniazdo które przekazano do funkcji accept
>>>c) Przekazanie funkcji socket zera w parametrze protocol spowoduje wybranie domyślnego protokołu dla podanej domeny i typu
>>>d) Gniazda typu SOCK_STREAM gwarantują, że dane zostaną odebrane w kolejności w jakiej zostały wysłane

Jaki sygnał otrzyma proces, który próbuje zapisać do segmentu pamięci dzielonej przeznaczonej jedynie do odczytu?
a) SIGTERM
b) SIGSHM
>>>c) SIGSEGV
d) SIGSEG

Do metod komunikacji międzyprocesowej POSIX należą:
>>>a) Pamięć wspólna (dzielona)
>>>b) Kolejki komunikatów
c) Sygnały
>>>d) Semafory
e) Łacza nienazwane (pipe)

Wskaż prawdziwe zdania:
>>>a) status zakończenia wątku możemy uzyskać poprzez funkcję pthread_join
b) pthread_kill zwalnia zasoby zużyte przez wątek
>>>c) argument wywołania przekazywany jest do wątku zawsze przez wskaźnik
>>>d) może się zdarzyć, że funkcja pthread_cancel nie zamknie wątku

Wykorzystanie sygnalizatora IPC_CREATE w wywołaniu funkcji msgget(semget, shmget):
a) zapewnia, że na pewno zostanie utworzony nowy zasób
b) w przypadku gdy istniał już zasób o podanym kluczu, powoduje usunięcie go i utworzenie nowego
>>>c) powoduje, że jeśli jeszcze nie był utworzony zasób o podanym kluczu to jest tworzony
d) ma sens tylko przy jednoczesnym zastosowaniu sygnalizatora IPC_EXCL
e) powoduje, że funkcja ta kończy się błędem, gdy zasób o podanym kluczu był już utworzony

Zaznacz prawdziwe zdania dotyczące mechanizmu pamięci wspólnej w IPC systemu V:
>>>a) możliwe jest dołączanie segmentu pamięci wspólnej do przestrzeni adresowej procesu w trybie wykonywania
>>>b) możliwe jest uzyskanie informacji o bieżącej liczbie dołączeń segmentu pamięci wspólnej
>>>c) możliwe jest dołączenie segmentu pamięci wspólnej do przestrzeni adresowej procesu w trybie tylko do odczytu
d) po utworzeniu segmentu pamięci wspólnej nie można już modyfikować żadnych atrybutów (elementów struktury shmid_ds)

Używając funkcji gethostbyname() możemy dowiedzieć się?
>>>a) Jaka jest oficjalna nazwa hosta
>>>b) Jakie są inne nazwy tego hosta
c) Jakie porty są w trybie nasłuchiwania, a więc którymi sie posłużyć
d) Jakie są uruchomione usługi sieciowe na hoscie(np. sshd, telnet)
>>>e) Jakie adresy wskazują na tego hosta

Gdy wątek (nie główny) wywoła funkcje_exit:
a) wątek wywołujący zostaje zablokowany do czasu zakończenia pracy przez wszystkie wątki procesu
b) nic się nie dzieje, tylko wątek główny może zakończyć proces 
>>>c) cały proces kończy swoją pracę
d) tylko wątek wywołujący zakończy swoją pracę, pozostałe wątki tego procesu działają nadal

Wskaż prawdziwe zdania:
>>>a) Wątek po wywołaniu funkcji pthread_exit(...) nie zwalnia zużytych zasobów
b) Wątki mogą być tworzone wyłącznie z wątku głównego
c) Wątki nie mogą korzystać ze zmiennych globalnych w związku z czym musza je otrzymać jako argumenty
d) Żądanie anulowania wątku jest obsługiwane natychmiast po odebraniu

Rozważmy funkcję systemową int semop(int semid, struct sembuf* wsk, size_t nops) Zaznacz prawdziwe zdania:
a) wsk jest wskaźnikiem do tablicy zawierającej zbiór semaforów o identyfikatorze semid
b) żadna z pozostałych odpowiedzi nie jest prawdziwa
c) wsk jest wskaźnikiem do struktury zawierającej definicję semafora, a nops jest rozmiarem tej struktury
>>>d) wsk jest wskaźnikiem do tablicy zawierającej operacje na semaforze, a nops określa ilość elementów w tablicy

Możliwe typy muteksa to:
>>>a) recursive mutex
>>>b) fast mutex
c) synchronised mutex
>>>d) errorchecking mutex
e) strange mutex

Utworzony z domyślnymi opcjami wątek charakteryzuje się tym, że:
a) Zasoby z nim związane są zwalniane automatycznie
>>>b) Jest typu joinable
c) Jego ID jest wartością zwracaną przez funkcję pthread_create, o ile nie wynosi ona -1 sygnalizująć błąd przy tworzeniu wątku
>>>d) Rozpoczyna działanie od funkcji przekazanej do pthread_create

Podniesienie opuszczonego semafora jest mozliwe:
a) jedynie przez proces, który utworzyl dany semafor funkcja semget 
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora 
>>> c) przez kazdy proces majacy dostep do danego semafora 
d) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora lub proces uprzywilejowany

Usunięcie kolejki przez funkcję msgctl:
>>>a) następuje natychmiast
b) zależy od flagi MSG_NOERROR
c) następuje gdy kolejka będzie pusta od momentu tego wywołania funkcji nie można już umieszczać komunikatów w kolejce
>>>d) może nastąpić tylko przez proces z uprawnieniamy twórcy kolejki lub nadzorcy systemu

Wielokrotne blokowanie jednego mutexu przez ten sam wątek:
a) powoduje wywłaszczenie pozostałych wątków
b) spowoduje zwrócenie błędu EBUSSY
c) będzie miało rezultat zależny od ustawionej zmiennej warunku
>>>d) spowoduje zablokowanie tego wątku, jeśli mutex jest mutexem szybkim
>>>e) nie spowoduje zablokowania tego wątku, jesli mutex jest rekurencyjny

Wielokrotne zamykanie jednego mutexa przez ten sam watek...
a) spowoduje zwrocenie bledu ELOCKED, jesli mutex jest mutexem sprawdzajacym bledy
>>>b) spowoduje zablokowanie sie watku, jesli mutex jest mutexem szybkim
c) powoduje anulowanie pozostalych watkow
>>>d) nie spowoduje zablokowania sie watku, jesli mutex jest rekurencyjny
e) bedzie mialo rezultat zalezny od ustawionej zmiennej warunku

Wywolanie: msgget(1234, O_CREAT|O_EXCL|0600)
a) gwarantuje stworzenie kolejki o identyfiaktorze 1234 do odczytu i zapisu wylacznie dla procesów tworzacego ja uzytkownika
>>>b) zwróci identyfikator kolejki o kluczu 1234, o ile kolejka nie istnieje
c) pobiera z kolejki o identyfikatorze 1234 komunikat
d) zwróci identyfikator kolejki o kluczu 1234, o ile kolejka istnieje 

Działanie funkcji sem_trywait(sem_t* sem) Które zdanie jest prawdziwe?
>>>a) jeżeli wartość semafora sem jest większa od zera, wówczas funkcja ta zmniejsza tą wartość po czym zwraca 0
>>>b) jeżeli wartość semafora sem wynosi zero, wówczas funkcja zwraca błąd i ustawia wartośćerrno na EAGAIN
c) jeżeli wartość semafora sem wynosi zero, wówczas funkcja ta blokuje proces do czasu aż inny proces zwiększy wartość semafora
d) jeżeli wartość semafora sem jest większa od zera, wówczas funkcja ta zwiększa tą wartość po czym zwraca 0

Wątki mają:
a) wspólny stos
>>>b) wspólny PID
c) wspólny Thread ID
>>>d) indywidualne maski sygnałów

Dla funkcji mq_notify prawdziwe są następujące stwierdzenia:
a) powiadomienie jest realizowane gdy kolejka jest pełna i pobrany zostanie komunikat(co spowoduje możliwość umieszczenia nowego komunikatu w kolejce)
>>>b) po powiadomieniu proces jest wyrejestrowany i musi się ponownie zarejestrować, aby uzyskać kolejne powiadomienie
>>>c) poza zarejestrowaniem powiadamiania funkcja umożliwia również wyrejestrowanie powiadamiania 
>>>d) ustawiane przez funkcję powiadamianie może być realizowane przez wysłanie sygnału
e) powiadomienie jest realizowane zawsze gdy dodawany jest nowy komunikat do pustej kolejki
>>>f) ustawiane przez funkcję powadamianie może być realizowane przez uruchomienie nowego wątku
g) powiadomienie jest realizowane zawsze gdy dodawany jest nowy komunikat do kolejki

Przy korzystaniu z gniazd domeny Unixa:
a) Nie należy używać funkcji bind
b) Nie jest możliwe korzystanie z trybu connectionless(SOCK_DGRAM)
>>c) Możemy utworzyć gniazdo w dowolnym miejscu struktury katalogów, do którego mamy prawo zapisu
d) Klient używa adresu 127.0.0.1

Dla funkcji sem_timewait prawdziwe są nastepujące zdania:
a) argument opisujący czas oczekiwania podaje się jako przedział czasu
b) funkcja ta zawsze (o ile nie pojawi się sygnał) blokuje proces na danym semaforze aż upłynie określony przez jeden z argumentów czas
>>>c) argument opisujący czas oczekiwania podaje się jako czas bezwzględny
d) funkcja ta realizuje opóźnione (aż upłynie określony przez jeden z argumentów czas) wykonanie operacji sem_wait
>>>e) gdy wartość semafora jest dodatnia to funkcja zachowuje się identycznie jak funkcja sem_wait

Czy możliwe jest nałożenie limitu na czas wykonywania operacji na grupie semaforów?
a) Nie
>>>b) Tak, używając funkcji semtimedop
c) Tak, ale semafor musi być odpowiednio utworzony(z użyciem SEM_TIMEDOPERATION)
d) Tak, odpowiednio używając funkcji semop

Wskaż prawdziwe zdania dotyczące standardu POSIX:
>>>a) jest to jeden ze standardów dla programowania systemowego
b) jest odmianą systemu UNIX
c) POSIX pozwala na zgodność programów na poziomie binarnym między różnymi systemami operacyjnymi
d) jest to inna nazwa dla Systemu V
>>>e) POSIX pozwala na zgodność programów na poziomie kodu źródłowego między różnymi systemami operacyjnymi

Wskaż zdanie fałszywe:
a) muteksy: rekurencyjny i sprawdzający błędy są specyficzną własnością GNU/Linuksa
b) w systemie Linux domyślnie tworzonym muteksem jest tzw. mutex szybki
>>>c) aby utworzyć muteks należy wywołać funkcję int pthread_init(pthread_mutex_t* mutex)
d) zmienna muteksu jest typu pthread_mutex_t

Rozmiar kolejki w systemi POSIX:
a) Może zostac zmieniony za pomocą funkcji mq_setattr
b) Jest stały dla wszystkich implementacji POSIX
c) Zależy wyłąćznie od implementacji (systemu operacyjnego)
>>>d) Jest ustawiany programowo przy tworzeniu kolejki

Funkcja pthread_cleanup_push:
a) usuwa funkcje ze zbioru funkcji czyszczących wątku
>>>b) rejestruje funkcje na stosie
>>>c) rejestruje funkcje która jest wywołana jak wątek wywoła funckje pthread_exit
d) blokuje proces

IPC - system V) Jaką wartość można ustawić jako trzeci argument funkcji semget?
a) IPC_PRIVATE
>>>b) IPC_CREATE  
c) IPC_NOWAIT  
d) SEM_UNDO

Funkcja, która ustala rozmiar nowo utworzonego obiektu pamięci wspólnej, albo zmienia rozmiar istniejącego obiektu to:
a) shm_setsize 
b) shm_open
>>>c) ftruncate
d) fstat

(IPC - system V) Do tworzenia kolejki komunikatów w systemie, służy funkcja:int msgget (key_t key, int flag) zwracająca identyfikator kolejki lub -1.
a) argument flag pozwala określić maksymalną liczbę komunikatów, które mogą znaleźć się w podanej kolejce
>>>b) argument flag pozwala określić prawa dostępu do kolejki
>>>c) podanie flagi równej wartości symbolicznej IPC_PRIVATE gwarantuje stworzenie nowej kolejki
d) kolejka zostanie zawsze stworzona, gdy zostanie podany dodatni całkowity klucz oraz jedną z flag będzie IPC.CREAT
e) do kolejki, od tej pory, funkcje systemowe uzyskują dostęp zarówno przez klucz, jak i przez zwrócony przez msgget identyfikator

(IPC - system V) Co powoduje podanie stałej IPC_PRIVATE jako argumentu key dla rodziny funkcji shmget, msgget, semget? Wybierz jedną lub więcej:
a) powoduje, że operacje na danym zasobie będą nieblokujące
>>>b) powoduje, że utworzona zostanie prywatna struktura, do której dostęp będą miały tylko procesy użytkownika, który daną strukturę utworzył, procesy innych użytkowników w żadnym wypadku nie będą mieć możliwości wykorzystania tak stworzonego obiektu
>>>c) powoduje utworzenie nowego zasobu
d) żadne z pozostałych

Lacza strumieniowe::Wybierz prawdziwe zdania dotyczace laczy strumieniowych.
>>>a)Pojedynczy proces moze uzywac tego samego deskryptora do zapisu i odczytu z lacza strumieniowego. 
>>>b)Lacza strumieniowe maja ograniczona pojemnosc 
>>>c)Lacza strumieniowe sa potokami nienazwanymi 
d)Lacza strumieniowe sa obslugiwane przez wszystkie systemy uniksowe 
e)Lacza strumieniowe moga byc tworzone funkcja int mkfifo(const char *name, mode_t mode) 
f)Lacza strumieniowe sa laczami jednokierunkowymi 

Synchronizacja::Ktore problemy moga sie przytrafic w wielowatkowych progamach dzialajacych bez synchronizacji?
>>>a) zaglodzenie
>>>b) wykluczenie
>>>c) spojnosci danych
>>>d) zawieszenie
e) restart programu

Mechanizm muteksow:
>>>a) umozliwia synchronizacje blokow kodu
b) umozliwia wykonywanie synchronizowanych blokow kodu przez wiele watkow jednoczesnie
c) wyklucza mozliwosc zakleszczenia programu
>>>d) moze wspolpracowac ze zmiennymi warunkow (Condition Variables)
e) znajduje sie w bibliotece conditionvariables.h

Blokady ReaderWriter::Blokady ReaderWriter:
>>>a) sa mechaniznem synchronizacji blokow kodu
>>>b) reprezentuje struktura pthread_rwlock_t
>>>c) umozliwiaja prace w trybie tylko do odczytu w synchronizowanych blokach kodu przez wiele watkow
d) umozliwiaja prace w trybie do zapisu w synchronizowanych blokach kodu przez wiele watkow
e) nie moga stanowic rozwiazania problemu spojnosci danych

Zmienne warunkowe:
>>>a) posiadaja implementacje w <pthread.h>
>>>b) oferuja mechanizm okreslania maskymalnego czasu oczekiwania przez watek
>>>c) moga zostac uzyte w polaczeniu z muteksami
d) w kazdej sytuacji dzialaja szybciej niz muteksy
e) oferuja komunikacje miedzyprocesowa

Teoria wielowatkowosci::Ktore z ponizszych zagadnien dotycza programow dzialajacych wspolbieznie:
>>>a) Problem filozofow
>>>b) Problem golibrody
>>>c) Problem nieatomicznosci rozkazow
d) Problem egzystencjalny
e) Problem biurokracji

Inicjacjalizacji mutexa z atrybutami domyslnymi mozna dokonac za pomoca instrukcji:?
>>>a) pthread_mutex_init(&mutex, NULL);
b) pthread_mutex_init(&mutex, PTHREAD_MUTEX_INITIALIZER);
c) pthread_mutex_init(&mutex, PTHREAD_MUTEX_DEFAULT);
d) pthread_mutex_init(&mutex, PTHREAD_MUTEX_DEFAULT_ATTR);
>>>e) mutex = PTHREAD_MUTEX_INITIALIZER;
f) mutex = NULL;

Wstrzymywanie::Ktore z podanych funkcji nigdy nie wstrzymuja wykonywania watku, lecz zawsze wracaja natychmiast?
a) int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)
>>>b)int pthread_mutex_trylock(pthread_mutex_t *mutex)
c) int pthread_mutex_lock(pthread_mutex_t *mutex)
>>>d) int sem_getvalue(sem_t *restrict sem, int *restrict sval)
>>>e) int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)
>>>f) int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)

Ktore funkcje sygnalizuja (niekoniecznie wszystkim) watkom oczekujacym na spelnienie warunku, ze zmienna warunku zostala zmieniona??
a) int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr)
>>>b) int pthread_cond_broadcast(pthread_cond_t *cond)
c) int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)
>>>d) int pthread_cond_signal(pthread_cond_t *cond)

Semafory::Wartosc semafora mozemy ustawic:?
a) Wewnatrz glownej funkcji wykonywanej przez watek, za pomoca funkcji sem_setvalue
>>>b) Przy inicjalizacji semafora
>>>c) W dowolnym miejscu programu (po inicjalizacji semafora), za pomoca funkcji sem_post
d) Wewnatrz funkcji main, za pomoca funkcji sem_setvalue

Mozliwe typy (atrybuty) dla muteksa to:?
>>>a) PTHREAD_MUTEX_NORMAL
>>>b) PTHREAD_MUTEX_ERRORCHECK
c) PTHREAD_MUTEX_DEADLKCHECK
>>>d) PTHREAD_MUTEX_RECURSIVE
>>>e) PTHREAD_MUTEX_DEFAULT
f) PTHREAD_MUTEX_DEADLK

::Funkcja clone::Funkcja clone:
a) sluzy tylko do tworzenia nowych procesow
b) sluzy tylko do tworzenia nowych watkow
>>>c) sluzy do tworzenia procesow i watkow
d) sluzy do tworzenia nowej instancji obiektu podawanego jako argument funkcji

::Watki::Dany jest fragment kodu:
#include <pthread.h>
//...
void* thread1(void* args) 
do_something();
return NULL;
void* thread2(void* args)
pthread_detach(pthread_self());
do_something();
return NULL;
int main() 
pthread_t t1, t2;
pthread_create(&t1,NULL,&thread1,NULL);
pthread_create(&t2,NULL,&thread2,NULL);
// ---1--
return 0;
Jaki kod powinien sie znalezc w miejscu ---1---, zeby funkcja zadzialala poprawnie:
a) Przede wszystkim, trzeba zmienic wywolanie funkcji pthread_create, poniewaz nie mozna do tej funkcji przesylac wskaznikow pustych.
b) Trzeba dodac dwie linijki:
pthread_join(t1,NULL);
pthread_join(t2,NULL);
c) Trzeba dodac trzy linijki:
void * result;
pthread_join(t1,result);
pthread_join(t2,result);
>>>d) Wystarczy dodac jedna linijke:
pthread_join(t1,NULL);

Teoria watkow::Watki w jednym procesie nie wspoldziela:
>>>a) Maski sygnalow
b) Zmiennych globalnych
>>>c) Stosu
d) Deskryptorow pliku
>>>e) Zmiennej errno

Funkcje "sprzatajace" po watkach::Wywolanie w watku funkcji pthread_cleanup_push(do_something,NULL), a zaraz po niej pthread_cleanup_pop(0) spowoduje, ze:
a) Przy zakonczeniu watku wykona sie funkcja do_something
b) Watek zakonczy sie natychmiast i wykona sie funkcja do_something
>>>c) Przy zakonczeniu watku nie wykona sie funkcja do_something
d) Watek sie nie zakonczy, ale w tym momencie wykona sie funkcja do_something
e) Watek sie zakonczy, a funkcja do_something nie wykona sie

Watki i ich funkcje::Pradziwe sa zdania: 
a) Watki zawsze sa implementowane albo jako watki poziomu uzytkownika, albo jako watki poziomu jadra
b) Wywolanie funkcji pthread_join z pierwszym argumentem -1 spowoduje, ze watek wywolujacy bedzie oczekiwal na zakonczenie wszystkich pozostalych watkow
>>>c) Komunikacja miedzy watkami jest szybsza niz komunikacja miedzy procesami
>>>d) Dzieki mechanizmom danych wewnatrzwatkowych mozna sprawic, ze wybrana zmienna globalna stanie sie niezalezna dla danego watku
>>>e) Do wysylania sygnalow pomiedzy watkami sluzy funkcja pthread_kill

Modele obslugi watkow::W modelu obslugi watkow "wiele na jeden" ... : 
>>>a)...wiele watkow poziomu uzytkownika jest odwzorowywanych na jeden watek jadra
b)...wiele watkow poziomu jadra jest odwzorowywanych na jeden watek uzytkownika
c)...wiele procesow ma jeden watek wykonania
>>>d)...wiele watkow jest wykonywanych w ramach jednego procesu

Konczenie watkow::Watek konczy swoje dzialanie gdy: 
>>>a) zakonczy swoje wykonanie funkcja, ktora wykonywal
>>>b) wywola funkcje pthread_exit
c) zawsze, gdy wywolamy na nim funkcje pthread_cancel

Identyfikatory watkow::Identyfikatory watkow mozna: 
>>>a)uzyskiwac funkcja pthread_self
>>>b)porownywac funkcja pthread_equal
>>>c)wykorzystywac do jednoznacznego identyfikowania watkow

Watki::Watki: 
>>>a) wspoldziela ze soba sekcje danych procesu
>>>b) wspoldziela ze soba sekcje kodu procesu
>>>c) moga posiadac "dane wlasne" - kazdy watek bedzie posiadac ich niezalezna kopie
d) nie moga byc realizowane jako biblioteka na poziomie uzytkownika

Sokety::Tworzac klienta uzywajacego soketow nalezy uzyc funkcji connect gdy korzystamy z:
a) komunikacji bezpolaczeniowej
>>>b) komunikacji strumieniowej
>>>c) komunikacji za pomoca protokolu TCP
d) komunikacji za pomoca protokolu UDP

Sokety::Funkcja accept:
>>>a) zwaraca nowy soket ktorego uzywamy do wlasciwej komunikacji
>>>b) wymaga najpierw wywolania funkcji listen na sokecie
>>>c) ulatwia komunikacje z wieloma polaczeniami naraz w obrebie jednego programu
d) nalezy ja wywolac w kliencie bezposrednio po stworzeniu soketu
e) nie jest funkcja ktora dotyczy zagadnienia soketow
f) jest zawsze wymagana do komunikacji

::Sokety::Stworzenie soketu z PF_INET6 jako rodzina protokolu komunikacji:
>>>a) jest poprawne
>>>b) tworzy nam lacze korzystajac z IPv6
c) umozliwa komunikacje za pomoca IPv6 oraz IPv4
d) tworzy lacze strumieniowe
e) tworzy lacze lokalne
f) tworzy lacze AppleTalk 

::Watki::Do synchronizacji watkow mozemy wykorzystac:
>>>a) semafory
>>>b) funkcje pthread_join()
c) funkcje zawarte w pliku naglowkowym pthread_synch.h
>>>d) zmienne warunku
>>>e) mutexy

::Inicjalizacja mutexa wartosciami domyslnymi::Mutex mozemy zainicjalizowac wartosciami domyslnymi w nastepujacy sposob:
a) pthread_mutex_t mutex = PTHREAD_DEFAULT_MUTEX_INITIALIZER
>>>b) pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
>>>c) za pomoca funkcji pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr), gdy drugi parametr jest rowny NULL
d) za pomoca funkcji pthread_mutex_init(pthread_mutex_t *mutex)
>>>e) poprzez wykonanie ciagu instrukcji:
 pthread_mutex_t mutex;
 pthread_mutexattr_t mta;
 pthread_mutexattr_init(&mta);
 pthread_mutex_init(&mutex, &mta);

::Wielokrotne zamykanie mutexa::Wielokrotne zamykanie jednego mutexa przez ten sam watek...
a) spowoduje zwrocenie bledu ELOCKED, jesli mutex jest mutexem sprawdzajacym bledy
>>>b) spowoduje zablokowanie sie watku, jesli mutex jest mutexem szybkim
c) powoduje anulowanie pozostalych watkow
>>>d) nie spowoduje zablokowania sie watku, jesli mutex jest rekurencyjny
e) bedzie mialo rezultat zalezny od ustawionej zmiennej warunku

W przypadku semaforow standardu POSIX:
>>>a) funkcja sem_wait() blokuje watek, az semafor bedzie mial wartosc dodatnia
b) funkcja sem_post() stanowi zadanie przydzielenia zasobow (licznik semafora jest dekrementowany)
c) funkcja sem_trypost() jest nieblokujaca wersja sem_post()
d) funkcja sem_destroy() moze byc uzywana do niszczenia semaforow niezaleznie od ich stanu
>>>e) funkcja sem_trywait() powraca z bledem EAGAIN, jesli licznik semafora jest rowny zero

::Watki::Ktore z ponizszych zdan dotyczacych funkcjipthread_cond_signal(pthread_cond_t *cond) i pthread_cond_broadcast(pthread_cond_t *cond) sa prawdziwe?
a) funkcja pthread_cond_signal() obudzi watek, ktory pierwszy wywolal pthread_cond_wait() na zmiennej warunku cond
b) funkcja pthread_cond_signal() zwroci blad, jesli zaden watek nie czeka na zmiennej warunku cond
>>>c) funkcja pthread_cond_broadcast() obudzi wszystkie watki czekajace na zmiennej warunku cond
>>>d) funkcja pthread_cond_broadcast() nie zwroci bledu, jesli zaden watek nie czeka na zmiennej warunku cond
>>>e) deklaracje tych funkcji znajduja sie w pliku naglowkowym pthread.h

::Watki::Watek anulowane synchronicznie: 
a) po otrzymanu zadania anulowania natychmiast konczy swoja prace
>>>b) moze zostac zakonczony tylko w wyznaczonych punktach
c) konczy swoje dzialanie rownoczesnie z watkiem, ktory go anulowal
>>>d) konczy dzialanie po dotarciu do funkcji void pthread_testcancel(void)
e) konczy dzialanie po dotarciu do funkcji void pthread_cancel(pthread_t tid)

::Watki::Jesli proces ma kilka watkow, to gdy zostanie do niego wyslany sygnal:
a) Zawsze otrzymuje go najstarszy watek.
b) Wedlug standardu POSIX otrzymuje go najmlodszy watek.
>>>c) W systemach linuxowych otrzymuje go najstarszy watek.
d) Wedlug standardu POSIX otrzymuje go najstarszy watek.
>>>e) Stadnadrd POSIX nie precyzuje, ktory z watkow otrzyma dany sygnal.

::Watki::Watki nalezace do tego samego procesu:
a) Wspoldziela ze soba stos procesu nadrzednego.
b) Otrzymuja kopie wszystkich zasobow systemowych procesu nadrzednego
>>>c) Kazdy z watkow posiada wlasny niezalezny stos.
>>>d) Zasoby systemowe procesu sa dzielone miedzy jego watki.
>>>e) Moga posiadac dane prywatne skojarzone z pewnymi kluczami dostepne tylko w watku, ktory dokanal takiego skojarzenia

::Watki::Wskaz prawdziwe zdania:
a) Do ustawiania atrybutow watku sluzy funkcja int pthread_set_attr(pthread_attr_t *attr)
>>>b) Atrybuty sa przechowywane w strukturze typu pthread_attr_t
>>>c) Atrybuty inicjalizuje sie domyslnymi wartosciami funkcja int pthread_attr_init(pthread_attr_t *attr)
d) Atrybuty inicjalizuje sie domyslnymi wartosciami funkcja int pthread_attr_default(pthread_attr_t *attr)
>>>e) Dla kazdego atrybutu istnieje funkcja pobierajaca i ustawiajaca jego wartosc.

::Watki::Czym roznia sie watki poziomu uzytkownika od watkow poziomu jadra
>>>a) Szybciej odbywa sie przelaczanie miedzy watkami poziomu uzytkownika
b) Szybciej odbywa sie przelaczanie miedzy watkami poziomu jadra
>>>c) W przypadku watkow poziomu jadra zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
d) W przypadku watkow poziomu uzytkownika zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
>>>e) Watki poziomu jadra sa obslugiwane jako pracujace w obrebie tej samej przestrzeni adresowej procesy.

Przesylanie danych przez gniazdko w trybie connection-oriented (SOCK_STREAM) w domenie Internetu:
>>> a) Powoduje, ze u odbiorcy dostajemy ten sam ciag bajtow, ktory wyslalismy
>>> b) Moze doprowadzic do blednej interpretacji liczb u odbiorcy (o ile nie zabezpieczymy sie przed tym)
c) Wymaga dopisywania do przesylanych danych naglowka warstwy transportu (numery segmentow, flagi protokolu TCP itd.)
>>> d) Wymaga istniejacego polaczenia pomiedzy gniazdami nadawcy i odbiorcy
e) Jest mozliwe tylko wtedy, gdy gniazko odbiorcy znajduje sie na <b>innym</b> komputerze

Poprawna sekwencja wywolan po stronie serwera, prowadzaca do akceptacji polacznia od klienta w strumieniowym trybie komunikacji (SOCK_STREAM):
a) socket, listen, accept, bind
b) listen, socket, bind, accept
>>> c) socket, bind, listen, accept
d) bind, socket, accept, listen

Przy korzystaniu z gniazd domeny Unixa:
>>> a) Mozemy utworzyc gniazdko w dowolnym miejscu struktury katalogow, do ktorego mamy prawa zapisu
b) Nie ma zadnych ograniczen przy tworzeniu gniazdek
>>> c) Do identyfikacji klienta nie powinno sie uzywac parametrow niezaleznych tylko w obrebie systemu (np. PID), poniewaz w przyszlosci komunikacja miedzy dwoma maszynami przez gniazdko na sieciowym systemie plikow moze stac sie mozliwa
d) Nie jest mozliwe korzystanie z trybu connecionless (SOCK_DGRAM)

Korzystanie z protokolu TCP przy gniazdach:
a) jest niemozliwe
b) jest mozliwe w dziedzinie UNIX w trybie connection-oriented (SOCK_STREAM)
c) jest mozliwe w dziedzinie Internetu w trybie connectionless (SOCK_DGRAM)
>>> d) jest mozliwe w dziedzinie Internetu w trybie connection-oriented (SOCK_STREAM)
>>> e) TCP jest domyslnym protokolem dla odpowiedniej pary dziedzina - tryb komunikacji

Zaakceptowanie polaczenia na sockecie (accept):
>>>a) Powoduje powstanie nowego otwartego deskryptora
b) Uniemozliwia zaakceptowanie nowego polaczenia na sockecie nasluchujacym przed zakonczeniem tego, ktore wlasnie przyjelismy
>>>c) Sprawia, ze komunikacja z klientem bedzie odbywac sie przez nowy deskryptor
d) Umozliwia komunikacje z klientem zarowno przez deskryptor zwrocony przez accept, jak i przez ten, na ktorym polaczenie zostalo odebrane

Aby zaakceptowac polaczenie i umozliwic komunikacje nalezy wywolac funkcje :
>>> a) accept
b) connect
c) setsockopt

Typ gniazda decyduje o tym w jaki sposob beda przekazywane dane. Dopuszczalne wartosci to:
>>>a) SOCK_STREAM
>>>b) SOCK_RAW
c) PF_PACKET
d) SOCK_DATGRAM

Funkcja bind sluzy do:
a) tworzenia socketu
b) nasluchiwania polaczen
c) odbierania i wyswietlania danych
>>>d) przyznania nazwy socketowi

W funkcji socket:
>>>a) pierwszy parametr okresla rodzine protokolow komunikacji
>>>b) parametr protocol jest zazwyczaj rowny 0
c) uzycie jako pierwszego parametru PF_INET6 sluzy do komunikacji w obrebie tylko jednej maszyny
>>>d) parametr type okresla typ socketu

Zaznacz prawidlowa odpowiedz:
a) Poniewaz sockety datagramowe wymagaja polaczenia, musimy na nie poczekac wywolujac funkcje listen()
b) sockety umozliwiaja komunikacje miedzy procesami tylko poprzez siec
c) do komunikacji miedzyprocesowej poprzes siec sluzy domena Unixowa
>>>d) nadanie nazwy socketowi odbywa sie przy pomocy funkcji bind()
e) nadanie nazwy socketowi odbywa sie przy pomocy funkcji socket()

::Struktury IPC::Do struktur IPC naleza: ?
a) sockety
>>>b) kolejki komunikatow
>>>c) pamiec wspolna
d) strumienie
>>>e) semafory
f) potoki

::Kolejki komunikatow::Kolejke komunikatow moze usunac: ?
a) kazdy
>>>b) proces, ktorego obowiazujacy identyfikator uzytkownika jest rowny msg_perm.cuid
>>>c) proces, ktorego obowiazujacy identyfikator uzytkownika jest rowny msg_perm.uid
d) proces, ktorego identyfikator grupy jest rowny msg_perm.gid
>>>e) proces majacy uprawnienia nadzorcy

Semafory:: wywolanie funkcji int semget (key_t key,int nsems, int flag): ?
>>>a) zwroci -1 w przypadku wystapienia bledu
b) zawsze utworzy nowa strukture IPC
>>>c) zwroci identyfikator semafora, gdy wszystko w porzadku
d) zwraca 0 gdy semafor o podanym kluczu juz istnieje

Pamiec wspolna:: W funkcji int shmctl (int shmid, int cmd, struct shmid_ds *buf) aby pobrac do buf strukture semid_ds nalezy uzyc opcji?
>>>a) IPC_STAT
b) IPC_SET
c) IPC_RMID
d) GETVAL
e) GETALL

Struktury IPC::Prawda jest, ze: ?
>>>a) mozliwe jest usuniecie kolejki komunikatow, nawet gdy sa procesy, ktore beda z niej korzystac
>>>b) pamiec wspolna moze uzywac do synchronizacji semaforow
>>>c) przy tworzeniu struktury IPC podajac klucz o wartosci IPC_PRIVATE mamy pewnosc, ze powstanie nowa struktura IPC
d) ilosc semaforow w systemie jest nieograniczona
>>>f) funkcja semop realizuje w sposob atomowy operacje na zbiorze semaforow

Jaka funkcja mozna wyslac dane do gniazda BEZPOLACZENIOWEGO? 
a) sck_snd(int, const void *, size_t)
b) write(int, const void *, size_t)
>>>c) send(int, const void *, size_t, int)
>>>d) sendto(int, const void *, size_t, int, const struct sockaddr*, socklen_t)

Podczas tworzenia socketu domena PF_UNIX w pierwszym argumencie odpowiada: 
a) komunikacji miedzy procesami systemu UNIX na roznych hostach.
b) komunikacji miedzy procesami dowolnych systemow na roznych hostach wedlug specyfikacji POSIX.
>>>c) komunikacji miedzy procesami dzialajacymi na tym samym hoscie.
d) komunikacji miedzy procesami systemu UNIX na roznych hostach kontrolowanej na niskim poziomie.
>>>e) komunikacji bedacej socketowym odpowiednikiem potokow (pipe)

Ktory z podanych typow gniazd jest najszybszy? 
a) polaczeniowe, strumieniowe (SOCK_STREAM)
>>>b) bezpolaczeniowe, niepewne (SOCK_DGRAM)
c) polaczeniowe, pakietowe (SOCK_SEQPACKET)
d) bezpolaczeniowe, pewne (SOCK_DRM)

Ktore z funkcji socket() i bind() musza znac strukture sock_addr, ktora chcemy zwiazac z gniazdem. 
a) Funkcja socket zna protokol oraz adres. Funkcja bind() rejestruje gotowe gniazdo do komunikacji, a system rozpoznaje adres na podstawie deskryptora gniazda.
b) Funkcja socket zna protokol oraz adres. Funkcja bind() rejestruje gotowe gniazdo ale DOSTAJE adres w argumencie, gdyz system nie odroznia dekstryptorow gniazd od deskryptorow plikow.
>>>c) Struktura sock_addr jest potrzebna do zerejestrowania gniazda w systemie funkcja bind(). Socket() zna jedynie protokol.
d) Struktura sock_addr jest wartoscia zwracana funkcji bind(). Socket() zna jedynie protokol.

Ktore z nastepujacych rodzin protokolow sa BLEDNE? 
a) PF_APPLETALK
b) PF_UNIX
c) PF_INET6
>>>d) PF_WIN

::POSIX::Komunikat znajdujacy sie w kolejce POSIX posiada nastepujace parametry:
>>>a) priorytet bedacy calkowita liczba bez znaku
>>>b) rozmiar obszaru danych w komunikacie
>>>c) dane
d) deskryptor pliku
e) numer kolejki

::POSIX::O POSIX-ie mozna powiedziec, ze:
>>>a) posiada mozliwosc powiadomienia o pojawieniu sie sygnalu w kolejce
b) nie obsluguje kolejek komunikatow
>>>c) posiada mozliwosc komunikacji miedzyprocesowej przy pomocy pamieci wspolnej
>>>d) ma wbudowana obsluge semaforow
e) rozwijamy skrot jako Port Operated Simultaneous Interface
>>>f) znany jest pod nazwa IEEE 1003

::POSIX::Nastepujace stwierdzenia dotyczace funkcji 'shm_unlink' sa prawdziwe:
>>>a) usuwa nazwe obiektu w pamieci wspolnej
b) zwraca deskryptor obiektu
>>>c) po jej wykonaniu, kolejne wywolania open nie powioda sie
>>>d) jako argument funkcja przyjmuje nazwe obiektu
e) pozwala zmodyfikowac flagi obiektu

::POSIX::Kolejki komunikatow mozemy wykorzystywac do:
>>>a) przesylania komunikatow miedzy procesami
b) ustalania zmiennych systemowych
>>>c) przesyla porcji bajtow skladajacych sie na komunikat
d) operacji na pamieci wspolnej

::POSIX::Nastepujace stwierdzenia dotyczace semaforow sa prawdziwe:
>>>a) sa podstawowym elementem sluzacym do synchronizacji roznych procesow
>>>b) rozrozniamy semafory nazwane i wystepujace w pamieci operacyjnej
>>>c) funkcja sem_destroy usuwa semafor z pamieci
d) funkcja sem_unlink usuwa semafor z pamieci
>>>e) funkcje obslugi semaforow znajduja sie w pliku nglowkowym <semaphore.h>

Funkcja int pthread_mutex_trylock(pthread_mutex_t *mutex); 
>>>a) Nie moze zablokowac watku 
b) Moze zablokowac caly proces 
c) Zawsze zwraca 0 
>>>d) Poprawnie wykorzystana zapobiega odwolaniu sie przez dwa watki do tego samego miejsca w pamieci 

Metody zakonczenia watku to:
>>>a) pthread_exit z wattku ktory chcemy zakonczyc 
b) pthread_exit z watku zewnetrznego
>>>c) pthread_cancel z watku zewnetrznego 
>>>d) return z procedury startowej watku 

::IPC - system V:: Do tworzenia kolejki komunikatów w systemie, sluzy funkcja: int msgget (key_t key, int flag) zwracajaca identyfikator kolejki lub -1.
a) argument flag pozwala okreslic maksymalna liczbe komunikatów, które moga znalezc sie w kolejce
b) kolejka zostanie zawsze stworzona, gdy zostanie podany dodatni calkowity klucz oraz jedna z flag bedzie IPC_CREAT
>>> c) podanie klucza równego wartosci symbolicznej IPC_PRIVATE gwarantuje stworzenie nowej kolejki
>>> d) argument flag pozwala okrsesic prawa dostepu do kolejki
e) argument flag pozwala okreslic prawa dostepu do kolejki
f) do kolejki, od tej pory, funkcje systemowe uzyskuja dostep zarówno przez klucz, jak i przez zwrócony przez msgget identyfikator

Stan "odlaczenia" watku::Gdy watek znajduje sie w stanie "odlaczonym" (detached):
>>>a) pamiec po nim zostanie zwolniona od razu po zakonczeniu jego dzialania
b) bedzie mozna pobrac wartosc przez niego zwrocona funkcja pthread_join
>>>c) mozna zakonczyc program nie oczekujac na zakonczenie watku funkcja pthread_join 

Sokety::Soketow w systemie Linux mozna uzywac do:
>>>a) komunikacji przez siec za pomoca protokolu TCP
>>>b) komunikacji przez siec za pomoca protokolu UDP
>>>c) komunikacji w obrebie jednego komputera
>>>d) podsluchiwania danych przechodzacych przez karte sieciowa
e) podsluchiwania wszystkich operacji dziejacych sie na komputerze

5. Sytuacja wyscigu (w kontekscie procesow) charakteryzuje sie tym, ze:
a) Procesy wysciguja sie, ktory bedzie szybszy i ktory zapisze szybciej na dysk plik. Proces wygrany, dostaje nagrode w postaci cukierka.
>>> b) Wiele procesow probuje wykonac jakies operacje na wspolnych danych i koncowy wynik zalezy od kolejnosci realizacji procesow
>>> c) Niepewnoscia, ktory proces zakonczy sie najpierw
>>> d) Mozna jej zaradzic uzywajac funkcji wait lub waitpid

1.Polecenie ftok:
a) sluzy do umieszczania danych w kolejce komunikatow.
>>>b) generuje klucz na podstawie nazwy sciezki i identyfikatora projektu
d) powoduje zmiane klucza juz utworzonego obiektu mechanizmu IPC
d) wyswietla informacje o wszystkich obiektach IPC istniejacych w systemie

2.Utworzenie nowego zestawu semaforow lub dostep do juz istniejacej zapewnia funkcja:
a)semcrt
b)semmk
>>> c)semget
d)semctl
e)semset

3.Ktore zdanie jest prawdziwe?
>>> a) Wywolanie funkcji msgsnd sluzy do umieszczania danych wkolejce komunikatow
b)funkcja msgsnd zwraca identyfikator kolejki komunikatow
c)funkcja msgrcv sluzy do ustawiania atrybutow kolejki
>>> d)struktura msqid_ds definiuje biezacy stan kolejki

Proces wywolujacy funkcje shmat:
>>> a) dolacza juz istniejacy segment pamieci do swojej przestrzeni adresowej
b) odlacza segment pamieci od swojej przestrzeni adresowej 
c) usuwa segment z jadra systemu
d) tworzy nowy segment pamieci dzielonej

1. Do czego sluzy funkcja ftok:
a) wysylania komunikatow
b) niszczenia semaforow
>>> c) generowania klucza
d) generowania id obiektu ipc

Proces A zamyka MUTEX M. W ktorych z przypadkach watek A lub B zostanie zablokowany, jezeli nastepnie: 
>>> a) A sprobuje zamknac M funkcja pthread_mutex_lock i M jest MUTEXem szybkim 
b) A sprobuje zamknac M funkcja pthread_mutex_lock i M jest MUTEXem rekurencjyjnym 
>>> c) B sprobuje zamknac M funkcja pthread_mutex_lock i M jest MUTEXem rekurencyjnym 
d) B sprobuje zamknac M funkcja pthread_mutex_trylock i M jest MUTEXem szybkim 

Watek asynchronicznie anulowalny 
a) Jest domyslnym rodzajem watku 
>>> b) Zostaje anulowany natychmiast po otrzymaniu zadania anulowania 
c) Zostaje anulowany dopiero po dotarciu do wyznaczonego miejsca 
d) Nie moze byc anulowany 

15 Watek zostaje zakonczony:
>>> a) Po wywolaniu funkcji execv z tego watku
>>> b) W chwili dotarcia do konca funkcji watku
>>> c) Po wywolaniu funkcji execl z jakiegos innego watku tego samego watku
>>> d) Po wywolaniu funkcji pthread_exit

1. Lacza komunikacyjne sa:
>>> a) poldupleksowe
b) dwukierunkowe
c) moga byc stosowane tylko przez procesy majace wspolnego potomka
d) zadna z odpowiedzi nie jest poprawna 

2.W przypadku lacza od procesu macierzystego do potomnego proces:
a) macierzysty zamyka koniec lacza do zapisu
b) potomny zamyka koniec lacza do odczytu
>>>c) macierzysty zamyka koniec lacza do odczytu
d) potomny otwiera koniec lacza do zapisu

3.Dla lacza, ktorego koniec do zapisu zostal zamkniety, funkcja read po przeczytaniu wszystkich danych przekazuje:
a) wartosc -1, aby wskazac blad
>>> b) wartosc 0, aby wskazac koniec pliku
c) liczbe odczytanych znakow
d) zadna z odpowiedzi nie jest prawdziwa

4.Jesli jako tryb w funkcji popen podamy paramatr:
a) "r", to nasz program bedzie zapisywac polecenia do standardowego wyjscia
b) "r", to nasz program bedzie odczytywal dane ze standardowego wejscia polecenia powloki
>>> c) "w", to nasz program bedzie zapisywac polecenia do standardowego wejscia
d) "w", to nasz program bedzie odczytywal dane ze standardowego wejscia 

2. Watki jednego procesu NIE dziela 
a) sekcji danych (zmienne globalne itd)
b) sekcji kodu programu- kod jest kopiowany dla kazdego watku osobno
>>>c) stosu - gdyby dzielily nie moglyby wywolywac roznych funkcji w roznych watkach
d) watki nic nie dziela miedzy soba

5. Identyfikator watku jest typu
a) zawsze typu int
>>> b) pthread_t 
c) thread
d) pid_t - taki sam typ jak dla procesu ale inna wartosc

3. Zakladamy, ze funkcje alocate_buffer oraz dealloc_buffer odpowiednio alokuja i zwalnia pamiec zajeta przez bufor podany w parametrze. Wywolanie funkcji do_some_work:
void do_some_work ()
 void *temp_buffer = alocate_buffer(1024);
 pthread_cleanup_push (dealloc_buffer, temp_buffer);
 /* jakies operacje na temp_buffer */
 pthread_cleanup_pop (0);
spowoduje:
a) Zaalokowanie bufora, wykonanie na nim operacji oraz jego zwolnienie
b) Blad w czasie kompilacji
>>>c) Zaalokowanie bufora i wykonanie na nim operacji bez zwolnienie pamieci
>>>d) Zarejestrowanie procedury czyszczacej
>>>e) Wyrejestrowanie procedury czyszczacej

Wspolnym terminem struktury IPC okreslamy:
a) kolejki komunikatow, kolejki FIFO, pamiec dzielona
b) kolejki komunikatow, pamiec dzielona, mechanizm ryglowania rekordow
d) kolejki FIFO, mechanizm ryglowania rekrdow, pamiec dzielona
>>d) kolejki komunikatow, semafory, pamiec dzielona

1. Proces to:
a) Program na dysku.
>>> b) Dzialajaca kopia jakiegos programu.
c) Program na dyskietce.
d) Program na cdromie, pod warunkiem ze cdrom jest nagrany w formacie iso.

2. Unikatowy numer, ktory otrzymuje kazdy nowo tworzony proces, nazywa sie:
a) GID
b) SID
c) UID
>>> d) PID
e) KID
f) DID
g) HID

3. Uzytkownik po wykonaniu polecenia ps -aux zobaczyl ku przerazeniu literki Z w polu STAT. Co sie stalo?
a) System zostal zawirusowany przez Bila Gatesa
b) Jakis wredny szpieg przejal sesje ssh i zmienil pola STAT
>>>c) Proces macierzysty nie oczekiwal na potomnego i w konsekwencji potomny zaczal straszyc inne procesy stajac sie ZOMBIE.
d) Nie jest mozliwe otrzymanie w wyniku polecenia ps literki Z

4. Segment TEKSTU (w kontekscie obszaru pamieci przeznaczonego dla procesu) to:
a) Miejsce, gdzie znajduja sie zmienne automatyczne oraz informacje zwiazane z kazdym wywolaniem fukncji
>>> b) Miejsce, gdzie znajduja sie instrukcje maszynowe
c) Dane, ktore w sosob jawny inicjowane sa w programie
d) Nie ma czegos takiego, pytanie jest zle sformulowane, nie ma w ogole o czym rozmawiac!

Jaka funcja sluzy do tworzenia semaforow?
>>> a) semget()
b) semctl()
c) semop()
d) semctl() z odpowiednia opcja

Kolejki komunikatow. Ktore zdanie jest prawdziwe?
a) msgctl() moze sluzyc do wysylania komunikatow
>>> b) msgctl() moze sluzyc do usuwania kolejki komunikatow
>>> c) kazda kolejka posiada swoj identyfikator
>>> d) msgget() sluzy do tworzenia kolejki komunikatow

Pamiec dzielona:
a) wymaga synchronizacji przy zapisywaniu i odczytywaniu z niej
b) jest przylaczana do procesu za pomoca funkcji shmget()
>>> c) umozliwia korzystanie z segmentu pamieci wielu procesom
d) nie moga z niej korzystac procesy potomne

Wyrozniamy 2 podstawowe operacje na semaforach:
>>> a) wejscie do sekcji krytycznej - wartosc semafora jest dekrementowana
>>> b) opuszczenie sekcji krytycznej - wartosc semafora jest inkrementowana
c) wejscie do sekcji krytycznej - wartosc semafora jest inkrementowana
d) opuszczenie sekcji krytycznej - wartosc semafora jest dekrementowana

Zasoby IPC. Ktore zdanie jest prawdziwe?
>>> a) klucz do zasobu IPC jest generowany na podstawie nazwy istniejacego pliku i dowolnej liczby calkowitej
b) kolejka komunikatow jest usuwana z pamieci po zakonczeniu procesu ktory operowal na niej
>>> c) flaga IPC_CREAT oznacza ze jesli zasob o podanym kluczu nie istnieje, to zostanie utworzony.
d) flaga IPC_PRIVATE oznacza ze z zasobu moze kozystac tylko dany proces oraz jego procesy potomne

Ktore z ponizszych zdan jest nieprawdziwe: 
a) Lacza komunikacyjne sa przekazywane tylko w jednym kierunku 
b) Lacza komunikacyjne mogą byc stosowane tylko przez proces majacy wspolnego przodka 
>>> c) Nie istnieje niebezpieczenstwo wymieszanie przesylanych danych naszego zapisu z zapisem danych z innego 

Ktore z ponizszych dokonczen zdania jest prawdziwe: "Koproces jest programem, ktory... "
>>> a) czyta ze stadnardowego WE i pisze na standardowe WY 
b) procesem wielokrotnie sie wykonujacym 
c) jest rodzajem demona 

Ktore z ponizszych zdan jest prawdziwe: 
a) polecenie mkfifo potrafi stworzyc pliki specjalne blokowe lub znakowe
>>> b) polecenie mknod potrafi stworzyc pliki specjalne blokowelub znakowe 
>>> c) jezeli proces chce zapisac mniejsza liczbe danych niz wynosi ilosc wolnego miejsca, to zostanie zapisane do lacza tyle bajtow ile proces chcial 
d) jezeli proces chce zapisac mniejsza liczbe danych niz wynosi ilosc wolnego miejsca, to proces sie zakonczy bez zapisania danych 

Ktora z ponizszych funkcji sluzy do odbierania komunikatow z kolejki:
a) semop
b) msgget
>>> c) msgrcv
d) printf

W jakiej strukturze jadra jest przechowywany zestaw semaforow:
a) sem
b) sembuf
>>> c) semid_ds
d) CSemSet
e) semafor
f) semfors_id

Ktory sposob komunikacji miedzy-procesowej jest najszybszy?
a) semafory
>>>b) pamiec wspoldzielona
c) kolejki komunikatow
d) potoki
f) alfabet morse'a

Metody zakonczenia watku to:
>>>a) pthread_exit z watku ktory chcemy zakonczyc
b) pthread_exit z watku zewnetrznego
>>>c) pthread_cancel z watku zewnetrznego
>>>d) return z procedury startowej watku

Co robi funkcja int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut); :
>>>a) zdejmuje blokade z mutexu mut
b) czeka okreslony przedzial czasu
>>>c) czeka na sygnal na zmiennej warunkowej cond
>>>d)jest cancel-pointem ( watek w czasie blokady na tej funkcji moze zostac anulowany )

Ktore z podanych funkcji sa cancel-pointami ( watki w czasie wykonywania tych funkcji moga zostac anulowane ) :
>>>a) pthread_cond_wait
b) pthread_mutex_lock
>>>c) pthread_testcancel
>>>d) sleep

Do pobrania id watku biezacego sluzy:
a) pthread_getid
b) pthread_myself
>>>c) pthread_self 
d) zadna

Dostepna dla zwyklego uzytkownika polityka schedulera jest:
>>> a) SCHED_OTHER v
b) SCHED_RR
c) SCHED_FIFO
d) zadna z powyzszych

Wywolanie: msgget(1234, O_CREAT|O_EXCL|0600)
a) gwarantuje stworzenie kolejki o kluczu 1234 do odczytu i zapisu wylacznie dla procesów tworzacego ja uzytkownika
b) gwarantuje stworzenie kolejki o identyfiaktorze 1234 do odczytu i zapisu wylacznie dla procesów tworzacego ja uzytkownika
>>> c) zwróci identyfikator kolejki o kluczu 1234, o ile kolejka nie istnieje
d) pobiera z kolejki o identyfikatorze 1234 komunikat
e) zadne z powyzszych stwierdzen nie jest prawdziwe
f) zwróci identyfikator kolejki o kluczu 1234, o ile kolejka istnieje 
 
Z kolejki komunikatow mozemy odczytac:
>>>a) pierwszy komunikat
b) ostatni komunikat
>>>c) pierwszy komunikat ktorego typ wynosi 5
>>>d) pierwszy komunikat ktorego typ jest rozny od 5
>>>e) pierwszy komunikat ktorego typ nie przekracza 5

Co wyniknie z wywolania semget(12, 34, O_CREAT|0600); ?
a) Funkcja zawsze zwroci blad
>>>b) Funkcja zwroci identyfikator zestawu semaforow o kluczu 12 (o ile istnieje)
c) Funkcja zwroci identyfikator zestawu semaforow o kluczu 34 (o ile istnieje)
d) Funkcja utworzy zestaw 12 semaforow o kluczu 34 (jesli nie istnieje)
>>>e) Funkcja utworzy zestaw 34 semaforow o kluczu 12 (jesli nie istnieje)

Ktora z ponizszych operacji moze zablokowac proces:
struct sembuf buf;
buf.sem_num = 0;
buf.sem_flg = 0;
a) buf.sem_op = 1; semop(id, &buf, 1);
>>>b) buf.sem_op = 0; semop(id, &buf, 1);
>>>c) buf.sem_op = -1; semop(id, &buf, 1);
d) buf.sem_op = -5; buf.sem_flg = IPC_NOWAIT; semop(id, &buf, 1);
e) buf.sem_op = 5; buf.sem_flg = IPC_NOWAIT; semop(id, &buf, 1);

Co wyniknie z wywolania: shmctl(1234, IPC_RMID, NULL);
a) Funkcja zawsze zwroci blad
b) Funkcja natychmiast usunie obszar pamieci o kluczu 1234
c) Funkcja natychmiast usunie obszar pamieci o identyfikatorze 1234
d) Funkcja oznaczy obszar pamieci o kluczu 1234 jako usuniety
>>>e) Funkcja oznaczy obszar pamieci o identyfikatorze 1234 jako usuniety

1. Chcac uzywac watkow w programie musisz dolaczyc plik naglowkowy biblioteke
>>>a) pthread
b) unixthread
c) threads
d) nie ma mozliwosci uzywaniea watkow w unixie bo nie definuje ich norma POSIX

3. MUTEX to
a) zwykla zmienna tylko nazwana inaczej ze wzgledu na zastosowanie
>>>b) rodzaj wzajemnego wykluczania (MUTual EXclusion) uzywany do synchronizacji watkow
c) rodzaj sygnalu systemowego uzywanego do synchronizacji miedzy watkami (MUlti Thread EXamination)
d) mechanizm systemowy uzywany w programach korzystajacych z watkow i wypisujacych na ekran (MultiUser TEXting)

4. Mechanizmy ktore NIE mechanizmem synchronizacji watkow to:
a) semafory
b) zmienne warunku
c) MUTEX
>>>d) pliki tymczasowe

1. Funkcja pthread_join:
a) Laczy dwa dowolne watki o ID podanych jako parametr
>>>b) Umozliwia przechwycenie wartosci zwracanej przez inny watek
>>>c) Usypia watek ja wywolujacy
>>>d) Generuje blad gdy watek poda jako argument swoj wlasny ID
>>>e) Zmusza watek do poczekania na zakonczenie innego watku

Ktore zdanie dotyczace funkcji pthread_exit jest nieprawdziwe:
a) Konczy dzialanie watku ktory ja wywolal.
>>>b) Jesli watek jest odlaczony wartosc zwracana bedzie pozniej dostepna dla funkcji pthread_join
c) Przyjmuje jako parametr wartosci jaka ma zostac zwrocona przez zakonczony watek
>>>d) Jesli jako drugi parametr podamy ID watku, watek ten zostanie zakonczony
>>>e) Ignoruje ona wszystkie procedury czyszczace i destruktory danych wlasnych

4. Ktore zdanie dotyczace danych wlasnych watkow jest prawdziwe:
a) Kazdy watek posiada swoj wlasny klucz do zapisu/odczytu danej
>>>b) Funkcja czyszczaca jest wywolywana bez wzgledu na to czy watek zostal anulowany czy zakonczony
c) Kazdy klucz trzeba powiazac z funkcja czyszczaca podczas jego tworzenia
d) Funkcja pthread_key_delete kasuje klucz wraz z danymi ktorych on dotyczy
e) Wywolanie setspecific zainicjuje klucz w przypadku gdy jest on jeszcze niezainicjowany

5. Dwukrotny wywolanie pthread_mutex_lock(&moj_mutex) spowoduje:
>>>a) Dwukrotne zablokowanie muteksu typu PTHREAD_MUTEX_RECURSIVE jesli funkcje wywolal ten sam watek
>>>b) Stala blokade muteksu typu PTHREAD_MUTEX_NORMAL jesli funkcje wywolal ten sam watek
c) Blad dla kazdego rodzaju muteksu
>>>d) Chwilowe uspienie jednego watku jesli funkcje wywolaly dwa rozne watki
e) Dwukrotne zablokowanie mutksu typu PTHREAD_MUTEX_ERRORCHECK jesli funkcje wywolal ten sam watek

2. Aby usunac segment pamieci dzielonej nalezy posluzyc sie funkcja:
a) shmrmv
b) shmdel
c) shmdt
d) shmemrmv
>>>e) shmctl

3. Gdy proces przylacza segment pamieci wspolnej
>>>a) MOZE zazadac konkretnego adresu dla tego segmentu
>>>b) MOZE pozwolic systemowi wybrac adres
c) MUSI zazadac konkretnego adresu
d) MUSI pozwolic systemowi na wybranie adresu
e) sposob okreslenia adresu tego segmentu zalezy od wywolanej funkcji

5. Semafor IPC to struktura obejmujaca wlasciwie zbior semaforow.
Funkcja systemowa semop pozwala wykonac operacje na:
a) pojedynczym elemencie semafora IPC
>>> b) pojedynczym semaforze IPC
c) zbiorze (przedstawionym za pomoca tablicy) semaforow IPC
d) zwyklych zmiennych calkowitych, ktore sa "klasycznymi" semaforami tylko z punktu widzenia programisty, a nie systemu

::Zasoby IPC::Ktore z zasobow sa zasobami IPC?
>>> a) Potoki nazwane i nienazwane
>>> b) Semafory
>>> c) Kolejki komunikatow
>>> d) gniazda dziedziny Uniksa(ang.UNIX domain sockets)

::Kolejki komunikatow::Aby usunac kolejke komuniaktow nalezy?
a) uzyc funkcji int msgdel(int msqid)
b) uzyc funkcji int msgget(key_t key,int msgflg) z msglfg ustawionym na O_MQDLT
>>>c) uzyc funkcji int msgctl(int msqid,int cmd,struct msqid_ds* buf) z polem cmd ustawionym na IPC_RMID
d) uzyc funckji int msgexec(int msqid,int cmd) z polem cmd ustawionym na IPC_MSQDLT

W ktorym pliku naglowkowym zadeklarowane sa funkcje obslugi watkow?
>>> a) pthread.h
b) stdio.h
c) stdlib.h
d) string.h

Watek jest niekiedy nazywany:
>>> a) lekkim procesem
b) ciezkim procesem
c) grubym procesem
d) twardym procesem

Wywolanie funkcji z rodziny exec w jednym z watkow danego procesu spowoduje:
>>> a) zakonczenie sie wszystkich watkow tego procesu
b) zakonczenie sie tylko tego jednego watku, wszystkie inne pozostana nienaruszone
>>> c) zastapienie biezacego procesu przez inny
d) wywolanie zostanie zignorowane, aby nie zniszczyc innych watkow tego procesu

::Watek odlaczony::Stworzylismy watek odlaczony. Po jego zakonczeniu:
a) ID oraz wartosc zwracana beda przechowywane do czasu, kiedy inny watek wywola funkcje pthread_join
>>> b) jest automatycznie czyszczony
c) zostanie utworzony nowy watek - kopia poprzedniego
d) zostanie odlaczone zasilanie plyty glownej

Funkcja pthread_mutex_trylock(&mut):
a) moze zablokowac dzialanie watku
>>> b) powroci od razu, jesli mutex mut jest zamkniety
>>> c) powroci od razu, jesli mutex mut jest otwarty
d) nie wykonuje absolutnie nic w systemie Linux

REKURENCYJNY mutex mut jest otwarty. Watek A wykonuje dwa razy pod rzad instrukcje: pthread_mutex_lock(&mut).
Zaden inny watek na muteksie mut w tej chwili nie operuje. Poprawne jest stwierdzenie:
a) Stan muteksu mut nie jest w tej chwili jednoznacznie okreslony
>>>b) Nie wystapi tu sytuacja zakleszczenia.
>>>c) Aby inny watek mogl zamknac mutex mut, watek A musi teraz wykonac pthread_mutex_unlock(&mut) dwukrotnie.
d) Drugie wywolanie pthread_mutex_lock(&mut) nie powiedzie sie, zostanie zwrocony blad.

::Zmienne warunkow::Wskaz stwierdzenia prawdziwe:
>>>a) Funkcja pthread_cond_broadcast wysyla informacje o zajsciu zdarzenia do wszystkich watkow oczekujacych na zajscie tego zdarzenia.
b) Funkcja pthread_cond_wait nigdy nie zablokuje dzialanie watku.
c) Zmienne warunkow sa jednym z mechanizmow synchronizacji procesow.
>>>d) Zmienne warunkow sa jednym z mechanizmow synchronizacji watkow.

O synchronizacji watkow mozna powiedziec, ze:
>>>a) Moze nieco spowolnic dzialanie programu, spowodowane wywolaniem funkcji obslugi mechanizmow synchronizacji.
b) Powinno sie jej unikac za wszelke cene w programach wielowatkowych.
>>>c) Jest mozliwa w systemie typu Linux.
>>>d) Stosowana jest w celu wyeliminowania problemow wynikajacych z jednoczesnej modyfikacji tych samych danych w roznych watkach.

Funkcja, ktora ustala rozmiar nowo utworzonego obiektu pamieci wspolnej, albo zmienia rozmiar istniejacego obiektu to:
a) shm_unlink
>>> b) ftruncate
c) fstat
d) shm_open

::Watki::Chcac uzywac watkow w programie musisz dolaczyc biblioteke
>>> a) pthread.h
b) unixthread.h
c) posixthreads.h
d) nie ma mozliwosci uzywania watkow w unixie bo nie definiuje ich norma POSIX

::Watki::Zakoczyc watek mozna uzywajac funkcji
>>> a) pthread_exit
>>> b) pthread_cancel w innym watku
c) pthread_sigmask
d) pthread_destroy

::Watki::Do tworzenia nowego watku sluzy funkcja
>>> a) pthread_create
b) pthread_join
c) pthread_equal
d) pthread_attr_init

::Watki::Sygnaly do watku wysyla sie funkcja
>>> a) pthread_kill
b) pthread_sigmask
c) send_signal
d) pthread_signal

::IPC systemu V::Zaznacz prawdziwe zdania?
>>> a) kazda kolejka ma swoj wlasny, unikalny identyfikator
>>> b) kolejka oraz zestaw semaforow moga miec taki sam identyfikator
c) funkcje rodziny get (msgget, semget, shmget) sluza jedynie do pobierania identyfikatorow instancji mechanizmow juz istniejacych w systemie
d) dana instancje mechanizmu komunikacji moze usunac jedynie proces, ktory ja utworzyl

::IPC systemu V::IPC_PRIVATE?
a) jest flaga sluzaca do tworzenia tylko instancji prywatnych, czyli np. kolejek dostepnych tylko dla danego procesu i jego potomkow
b) jest kluczem, a zatem odpowiada mu tylko jeden identyfikator
>>> c) wymusza utworzenie nowej instancji obiektu
d) wymusza utworzenie nowej instancji wtedy, gdy ustawiona jest flaga IPC_CREAT 
>>> e) moze istniec wiele mechanizmow danego typu (np. wiele zestawow semaforow) o takim kluczu

::Funkcja msgctl::Funkcja msgctl mozemy?
>>> a) zapisac prawa dostepu, informacji o uzytkowniku oraz maksymalnej pojemnosci kolejki
b) spowodowac usuniecie kolejki po tym jak wszystkie procesy oczekujace na czytanie z niej zostana obsluzone
>>> c) spowodowac natychmiastowe usuniecie kolejki
>>> d)pobrac informacje ze struktury kontrolnej msqid_ds

::Semafory::Funkcja semop?
>>> a) moze sluzyc do zmniejszania wartosci semaforow
b) nie mozna jej uzyc do zwiekszenia wartosci semafora, poniewaz za to odpowiedzialne jest jadro systemu
>>> c) moze sluzyc do zmiany wartosci jednego semafora
d) konieczne jest zamaskowanie sygnalow przed wywolaniem funkcji, gdyz operacje na wielu semaforach moga nie byc wykonane jednoczesnie

::Pamiec wspoldzielona::Segment pamieci wspoldzielonej?
a) moze byc "tylko do zapisu"
>>> b) moze byc "tylko do odczytu"
c) moze byc "tylko albo do zapisu", albo "tylko do odczytu"
>>> d) jest dziedziczony przez potomka po wywolaniu funkcji fork()
e) jest odlaczany i usuwany po wykonaniu exit()

Jezeli watek A zablokuje rekurencyjny MUTEX M to:
a) Ponowna proba blokady MUTEXu M przez watek A wstrzyma jego prace
>>>b) Ponowna proba blokady MUTEXu M przez watek A NIE wstrzyma jego pracy
>>>c) Proba blokady MUTEXu M przez watek B wstrzyma prace watku B
d) Proba blokady MUTEXu M przez watek B wstrzyma prace watku A

Funkcja pthread_mutex_trylock:
a) Probuje zablokowac watek, ktory ja wywoluje
b) Nigdy nie blokuje MUTEXu podanego w argumencie
>>>c) Nigdy nie wstrzymuje pracy watku ja wywolujacego
d) Jako drugi argument pobiera ile razy ma probowac zablokowac MUTEX

Semafory::Semafory wykorzystywane do synchronizacji watkow:
>>>a) Moga byc Semaforami standardu POSIX
b) Roznia sie od innych Semaforow tym, ze moga przyjmowac wartosci ujemne
c) Wymagaja dolaczenia do kodu programu biblioteki <semthread.h>
d) Dzialaja wylacznie w polaczeniu z MUTEXami

Semafory::Funkcja sem_wait uzyta do synchronizacji watkow:
>>>a) Dla Semafora o wartosci dodatniej, zmniejszy jego wartosc
>>>b) Zawsze przed zakonczeniem sie wykonywania zmniejszy wartosc Semafora
>>>c) Gdy wartosc Semafora wynosi 0, wstrzyma prace watku ja wywolujacego
>>>d) Niewlasciwie uzyta moze byc powodem zakleszczenia sie watkow

Zmienne warunkow::Funkcja pthread_cond_wait:
>>>a) Wstrzymuje prace watku i oczekuje na sygnal zmiany zmiennej warunku
b) Wstrzymuje prace watku w zaleznosci od spelnienia warunku dla zmiennej
>>>c) Pobiera w argumentach wskaznik na MUTEX
d) Nie wstrzyma pracy watku, ktory zablokowal wiecej niz jeden MUTEX

::IPC Systemu V::W Systemie V wprowadzono 3 dodatkowe sposoby komunikacji miedzyprocesowej. Naleza do nich:
>>>a) kolejki komunikatow
>>>b) semafory
>>>c) pamiec wspolna
d) lacza komunikacyjne
e) synaly

::IPC Systemu V::Aby wyswietlic wszystkie zasoby IPC w systemie uzywamy komendy
>>>a) ipcs
b) ls -ipc
c) ps -ipc

::Kolejki komunikatow::Co jest niezbedne aby dzialac na kolejce komunikatow?
>>>a) liczbowy identyfikator kolejki komunikatow
>>>b) odpowiednie prawa dostepu
c) wlasna obsluga sygnalu SIGCHLD
d) nazwa kolejki komunikatow

::Semafory::Semafor to:
>>>a) licznik sluzacy do regulowania dostepu do wspolnych zasobow
b) inne okreslenie sygnalu czasu rzeczywistego
c) proces, ktory blokuje zasoby

Do oblsugi pamieci wspolnej sluzy zestaw funkcji:
>>>a) shmget, shmat, shmdt, shmctl
b) semget, semop, semctl
c) msgget, msgsnd, msgrcv, msgctl

IPC::Funkcja,ktora odwzorowuje nazwe sciazki pliku na klucz zasobu IPC to:
a) int ftok(const char* path, int id)
b) double ftok(char* path,key_t id)
>>> c) key_t ftok(const char* path,int id)
d) ipc_t ftok(int id,char* path)

::Kolejki komunikatow::Wywolanie msgget(key, IPC_CREAT | IPC_EXCL) zwroci?
>>>a) identyfikator kolejki,jesli kolejka nie istenieje
b) identyfikator kolejki,nawet jesli kolejka istnieje
>>> c) wartosc -1,jesli kolejka juz istnieje
d) ta funckcja nic nie zwraca

::Semafory::Wskaznik do tablicy semaforow oraz czas ostatniej zmiany znajdziemy w strukturze?
a) sembuf
b) semum
>>> c) semid_ds
d) sem_t

::Konczenie watkow::Utworzylismy nowy watek funkcja pthread_create. Gdy bedziemy chcieli zakonczyc ten watek bez konczenia procesu, mozemy w funkcji tego watku wywolac funkcje:
>>> a) return
b) escape
c) exit
>>> d) pthread_exit

::Zmienne warunkow::Wskaz stwierdzenia prawdziwe: 
>>>a) Funkcja pthread_cond_broadcast wysyla informacje o zajsciu zdarzenia do wszystkich watkow oczekujacych na zajscie tego zdarzenia.
b) Funkcja pthread_cond_wait nigdy nie zablokuje dzialanie watku.
c) Zmienne warunkow sa jednym z mechanizmow synchronizacji procesow.
>>>d) Zmienne warunkow sa jednym z mechanizmow synchronizacji watkow.

Zaznacz poprawne zdania dotyczace semaforow: 
>>> a) funkcja sem_open zwraca wskaznik semafora lub SEM_FAILED w przypadku bledu
>>> b) funkcja sem_post zwieksza wartosc semafora sem o 1 i budzi jeden z watkow oczekujacych na dodatnia wartosc semafora
c) semafor mozna usunac z pamieci niezaleznie od wartosci licznika odwolan
d) funckja sem_wait moze zwracac blad EAGAIN

W przypadku lacza od procesu potomnego do macierzystego:
a) proces macierzysty zamyka koniec lacza do odczytu
>>> b) proces macierzysty zamyka koniec lacza do zapisu
c) proces potomny zamyka koniec lacza do zapisu
>>> d) proces potomny zamyka koniec lacza do odczytu

O synchronizacji watkow mozna powiedziec, ze: 
>>> a) Moze nieco spowolnic dzialanie programu, spowodowane wywolaniem funkcji obslugi mechanizmow synchronizacji.
b) Powinno sie jej unikac za wszelke cene w programach wielowatkowych.
>>> c) Jest mozliwa w systemie typu Linux.
>>> d)Stosowana jest w celu wyeliminowania problemow wynikajacych z jednoczesnej modyfikacji tych samych danych w roznych watkach.

4. Funkcja mq_open:
a) W przypadku, gdy kolejka nie istnieje, zawsze wraca z bledem
b) W przypadku, gdy kolejka nie istnieje, zawsze ja tworzy
>>> c) Zwraca -1 w przypadku bledu
>>> d) Zwraca wartosc nazywana deskryptorem kolejki komunikatów
>>> e) Pozwala na ustalenie praw dostepu do kolejki uzytkownikowi, grupie i innym
f) umozliwa otwarcie kolejki tylko do odczytu, w przypadku zastosowania flagi O_WRONLY

Struktura mq_attr zawiera 
>>> a) pole mq_maxmsg, ktore okresla maksymalna liczbe komunikatow w kolejce
b) pole mq_cnt, ktore okresla liczbe komunikatow w kolejce
>>> c) pole mq_msgsize, ktore okresla maksymalny rozmiar komunikatu w bajtach
>>> d) pole mq_flags, ktore ustawione na wartosc O_NONBLOCK wlacza nieblokowanie funkcji odbioru i wysylania

::Dzialanie funkcji select::Funkcja select:
a) sluzy do zwielokrotniania wejscia-wyjscia
>>>b) przyjmuje jako pierwszy argument (maxfdp1) maksymalna liczbe deskryptorow
c) ma 4 mozliwe wartosci powrotu
d) wraz z funkcja poll realizuje asynchroniczna forme powiadamiania

W funkcji void *mmap(void *start ,size_t lenght, int prot, int flags, int fd, off_t offset) 
>>> a) adres, pod ktory zlecamy zmapowanie pamieci start, jest tylko propozycja
b) zmapowanie pamieci odbywa sie zawsze pod podany adres start
c) argument prot z wartoscia PROT_EXEC powoduje, ze strony nie moga byc dostepne
>>> d) flaga MAP_SHARED poleca wspoldzielenie mapowania ze wszystkimi innymi procesami

::Pamiec wspólna::Wskaz prawdziwe zdanie:
>>> a) Tworzymy ja przy pomocy funkcji shm_open(const char *name, int oflag, mode_t mode)
b) Po wywolaniu funkcji shm_open nie musimy mapowac obiektu pamieci wspólnej na przestrzen adresowa w pamieci
c) moze z niej korzystac tylko jeden okreslony proces
>>> d) Aby korzystac z funkcji które ja obsluguja nalezy zainkludowac plik sys/mman.h

::IPC - System V::W strukturze shmid_ds opisujacej segment pamieci wspólnej wystepuja nastepujace pola:
>>> a) czas ostatniego odlaczenia
>>> b) identyfikator procesu ostatniej operacji
>>> c) czas ostatniego dolaczenia
>>> d) biezaca liczba dolaczen

Protokoly datagramowe charakteryzuja sie tym ze:
 a) Zapewniaja kontrole poprawnosci przesylanych danych
>>> b) Dane nie musza docierac do odbiorcy w tej samej kolejnosci w jakiej byly wyslane
 c) Protokól TCP jest protokolem datagramowym
>>> d) Protokól UDP jest protokolem datagramowym

::Funkcja mq_receive::Wskaz zdania prawdziwe
a) wywolanie funkcji mq_receive nigdy nie blokuje procesu
>>>b) blokowanie funkcji zalezy od parametrów okreslonych podczas tworzenia kolejki komunikatów
c) blokowanie zalezy od implementacji w danym systemie operacyjnym
d) wywolanie funkcji mq_receive zawsze blokuje proces w momencie gdy w kolejce nie ma komunikatów

::Funkcja mq_receive::Funkcja mq_receive:
a) wysyla komunikat do kolejki
>>> b) odbiera komunikat z kolejki
>>> c) zwraca liczba odebranych bajtów i -1 w przypadku bledu
d) zwraca 0 w przypadku powodzenia, -1 w przypadku bledu 

::IPC - system V:: Jaka wartosc mozna ustawic jako trzeci argument funkcji semget ?
a) IPC_PRIVATE
b) IPC_NOWAIT
c) SEM_UNDO
d) SEM_NOERROR
>>> e) IPC_CREAT

Zaznacz funkcje, które nie sluza do obslugi pamieci wspólnej POSIX:
>>> a) malloc
>>> b) shm_create
c) fstat
>>> d) realloc
e) shm_open

::IPC - system V:: Zaznacz prawdziwe zdania:
a) Funkcja shmdt sluzy do powiekszenia rozmiaru przylaczonego segmentu pamieci wspólnej
b) Ustawienie w wywolaniu shmat sygnalizatora SHM_UNDO umozliwia zapamietanie zmian zawartosci segmentu oraz przywrócenie starego stanu
>>> c) Dzieki uzyciu sygnalizatora mozna podczas wywolania shmat okreslic, czy segment ma byc dolaczony w trybie do odczytu i zapisu, czy tylko do odczytu
d) Zadna z pozostalych odpowiedzi nie jest prawdziwa
>>> e) Struktura shmid_ds zawiera m.in. informacje o biezacej liczbie dolaczen do segmentu

Co to jest POSIX?
>>> a) Standard interfejsów ulatwiajacy przenosnosc programow
b) Funkcja systemowa
c) System operacyjny
d) Definuje zalecany sposób wzajemnego oddzialywania aplikacji i systemu operacyjnego

10 Po wywolaniu funkcji int shm_unlink (const char * name):
 a) Obiekt zostanie usuniety bez wzgledu na liczbe odwolan do niego
 b) Zostana zamkniete wszystkie odwolania do obiektu wskazywanego przez name, a obiekt pozostanie w pamieci
 c) Obiekt zostanie natychmiast usuniety, jesli ta funkcje wywola proces który utworzyl pamiec (bez wzgledu czy istnieja inne odwolania do tej pamieci)
>>> d) Obiekt zostanie usuniety gdy liczba odwolan do niego wyniesie zero 

13 Semafory nazwane tworzymy za pomoca funkcji:
a) sem_create
b) sem_createnamed
c) sem_init
>>> d) sem_open

::IPC - system V:: Do ustawienia wartosci poczatkowych semaforom sluzy funkcja:
a) semset
b) semmk
>>> c) semctl
d) semadd
e) seminit

::IPC - system V:: Które z ponizszych zdan sa prawdziwe?
a) funkcja ftok generuje klucz tylko na podstawie nazwy sciezki podanej jako parametr
>>> b) funkcja ftok generuje klucz na podstawie nazwy sciezki oraz identyfikatora projektu podanych jako parametry
>>> c) sciezka podana jako parametr funkcji ftok musi sie odnosic do istniejacego pliku
d) funkcja ftok przy kazdym wywolaniu z tymi samymi parametrami zwróci inny klucz

::IPC - system V:: Efektem dzialania funkcji msgctl jest:
>>> a) pobranie struktury msqid_ds opisujacej kolejke komunikatów jesli argument cmd ma wartosc IPC_STAT
b) utworzenie/dowiazanie do kolejki, jesli argument ma wartosc IPC_CREAT
>>> c) usuniecie kolejki z systemu, jesli argument ma wartosc IPC_RMID
d) zadne z pozostalych zdan nie jest prawdziwe

::Funkcja mq_close::
a) Jeden z jej parametrów okresla, czy ma zamknac czy usunac kolejke
b) Sluzy do usuwania kolejki komunikatów z systemu
>>> c) Sluzy do zamkniecia kolejki komunikatów bez jej usuwania
d) Nie jest funkcja systemu POSIX

::IPC - system V:: Funkcja ftok zwraca:
a) adres nowo utworzonego segmentu pamieci wspólnej
b) deskryptor pliku dla sciezki bedacej argumentem funkcji
c) identyfikator kolejki komunikatów
>>> d) klucz zasobu powiazany z podana sciezka i numerem

4. Wskaz zdania charakteryzujace uzycie flagi IPC_STAT w funkcji msgctl:
a) umozliwia zmiane id uzytkownika, który stworzyl strukture
b) umozliwia zmiane gid uzytkownika, który stworzyl strukture
>>> c) zadna odpowiedz nie jest poprawna
d) umozliwia zmiane id uzytkownika, który ostatnio korzystal ze struktury 

9. Dostep do struktury IPC ma:
a) kazdy proces
b) zalezy to od implementacji systemu
>>> c) proces który ja utworzyl i jego potomkowie
>>> d) atrybuty dostepu mozna ustalic podczas tworzenia struktury

Ktora z funkcji mozemy ustawic flage O_NONBLOCK dla pliku?
>>> a) fcntl()
b) fopen()
c) fstat()
d) open()

::IPC - system V:: Zaznacz prawdziwe zdania:
a) Zadna z pozostalych odpowiedzi nie jest prawdziwa
b) Funkcja shmget tworzy segment pamieci wspólnej i dolacza go do przestrzeni adresowej procesu wywolujacego
c) Funkcja shmdt sluzy do dolaczenia istniejacego segmentu pamieci wspólnej do przestrzeni adresowej procesu
>>> d) Przy uzyciu funkcji shmctl mozna miedzy innymi usunac z systemu segment pamieci wspólnej lub tez, w przypadku bycia nadzorca systemu, zaryglowac lub odryglowac segment pamieci wspólnej
>>> e) Funkcja shmat zwraca wskaznik do segmentu pamieci wspólnej, jesli operacja zakonczyla sie sukcesem

::IPC - system V:: Podniesienie opuszczonego semafora jest mozliwe:
a) jedynie przez proces, który utworzyl dany semafor funkcja semget 
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora
>>> c) przez kazdy proces majacy dostep do danego semafora 

::IPC - system V:: Zaznacz zdania falszywe:
a) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej ale ich nie zwalnia 
b) Wykonujac polecenie ipcs z flaga -m mozna uzyskac informacje o segmentach pamieci wspóldzielonej w systemie 
>>> c) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej od przestrzeni adresowej tego procesu oraz usuwa segmenty z systemu 
d) Uzycie jako parametru wywolania shmctl stalej IPC_STAT oraz przekazanie wskaznika do struktury shmid_ds umozliwia pobranie informacji o segmencie 

Poprawna pod wzgledem standardu inicjalizacja muteksu ma postac:
1) pthread_mutex_t mut;
   pthread_mutex_init(&mutex, NULL);
2) pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
3) pthread_mutex_t mut = NULL;
4) pthread_mutex_t mut = malloc(sizeof(pthread_mutex_t));
a) Odpowiedz 3 jest poprawna   
b) Odpowiedz 4 jest poprawna   
>>>c) Odpowiedz 2 jest poprawna   
>>>d) Odpowiedz 1 jest poprawna   

Przesylanie danych przez gniazdo w trybie connection-oriented (SOCK_STREAM) w domenie Internet:
>>> a) Powoduje, ze u odbiorcy dostajemy ten sam ciag bajtów, który wyslalismy   
b) Moze doprowadzic do blednej interpretacji liczb u odbiorcy (o ile nie zabezpieczymy sie przed tym)   
c) Wymaga dopisywania do przesylanych danych naglówka warstwy transportu (numery segmentów, flagi protokolu TCP itd))   
>>> d) Wymaga istniejacego polaczenia pomiedzy gniazdami nadawcy i odbiorcy   
e) Jest mozliwe tylko wtedy, gdy gniazdo odbiorcy znajduje sie na innym komputerze   

W jaki sposób mozna umozliwic dostep do semafora POSIXowego dla róznych procesów
a) Semafory moga byc dostepne tylko w jednym procesie, gdyz sluza do synchronizacji watków 
b) Przy zmianie ustawien semafora (funkcja sem_setproperty) 
>>> c) Przy inicjalizacji semafora (funkcja sem_init) 

::IPC - system V::Zaznacz prawdziwe zdania z nastepujacych:
a) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipc 
b) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipcls 
>>> c) do usuniecia zasobu IPC systemu V sluzy polecenie ipcrm 
d) do usuniecia zasobu IPC systemu V sluzy polecenie rmipc 

::IPC - system V:: Pojedyncze wywolanie funkcji msgrcv umozliwia odczytanie z kolejki komunikatów:
>>> a) pierwszego umieszczonego w niej komunikat (kolejka FIFO) 
b) ostatnio umieszczonego w niej komunikatu, którego typ nie przekracza wartosci bezwzglednej parametru okreslonego w wywolaniu 
c) ostatnio umieszczonego w niej komunikatu (kolejka LIFO) 
d) ostatnio umieszczonego w niej komunikatu o okreslonym w wywolaniu typie 
>>> e) pierwszego komunikatu o okreslonym w wywolaniu typie

Chcac uzywac watków w programie trzeba dolaczyc biblioteke:
a) posixthreads
>>>b) pthread
c) unixthread
d) nie ma mozliwosci uzywania watkow w unixie bo nie definiuje ich norma POSIX

Adres IPv4 petli zwrotnej polaczen sieciowych (tzw loopback) to:?
a) 255.0.0.255
b) 127.0.0.255
>>>c) 127.0.0.1
d) 127.0.0.0
e) 0.0.0.0

(IPC - system V) W kolejce komunikatów umieszczono w podanej kolejnosci nastepujace wiadomosci:
1. 'Ala ma kota' -- typ 10
2. 'Ela ma psa' -- typ 5
3. 'Ola ma rybki' -- typ 15
O której z pan odczytamy informacje, jesli w wywolaniu funkcji msgrcv jako argument dotyczacy typu podamy wartosc -12 ?
Wybierz co najmniej jedna odpowiedz
a) o Oli
>>> b) o Eli
c) o zadnej z nich; funkcja zwróci -1 gdyz w kolejce nie wystepuje komunikat o podanym typie
d) o Ali

(IPC - system V) Do metod komunikacji miedzyprocesowej IPC Systemu V naleza:
>>>a) kolejki komunikatów, semafory, pamiec dzielona
b) kolejki komunikatów, pamiec dzielona, ryglowania rekordów
c) kolejki komunikatów, potoki, pamiec dzielona
d) wszystkie mechanizmy komunikacji miedzyprocesowej w Systemach UNIX V
e) potoki, ryglowanie rekordów, pamiec dzielona

Które funkcje powduja calkowite usuniecie kolejki Posix z systemu?
a) int mq_close(mqd_t mqdes);
>>>b) int mq_unlink(const char *name);
c) int mq_delete(mqd_t mqdes);
d) int mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr) z odpowiednimi atrybutami
e) int mq_remove(mqd_t mqdes);

(IPC - system V) W strukturze shmid_ds opisujacej segment pamieci wspólnej wystepuja nastepujace pola:
>>>a) czas ostatniego dolaczenia
>>>b) czas ostatniego odlaczenia
>>>c) identyfikator procesu ostatniej operacji
>>>d) biezaca liczba dolaczen

Nazwy obiektów POSIX
a) Moga miec dlugosc co najwyzej 8 znaków
b) Moga byc dowolnymi ciagami znaków
c) Maja postac nazwy pliku, przy czym nie musi on istniec w systemie
>>> d) Maja postac nazwy pliku, przy czym musi on istniec w systemie
e) Sa identyfikatorami calkowitoliczbowymi

(IPC - system V) Próba opuszczenia semafora o wartosci 0 powoduje:
a) zakonczenie procesu, który próbuje opuscic semafor
b) nic sie nie stanie
c) zwrócenie bledu przez funkcje semop
>>>d) uspienie procesu, który próbuje opuscic semafor

Funkcja sem_open:: Wybierz co najmniej jedna odpowiedz
>>>a) W przypadku istnienia semafora o podanej nazwie, otwiera go zamiast tworzyc (gdy nie ma ustawione flagi O_EXCL)
b) Zwraca identyfikator semafora jako wartosc typu int
>>>c) Sluzy do tworzenia semafora POSIX
d) Sluzy do tworzenia semafora IPC V

Czym róznia sie watki poziomu uzytkownika od watków poziomu jadra
a) W przypadku watków poziomu uzytkownika zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
>>>b) Szybciej odbywa sie przelaczanie miedzy watkami poziomu uzytkownika
>>>c) Watki poziomu jadra sa obslugiwane jako pracujace w obrebie tej samej przestrzeni adresowej procesy.
>>>d) W przypadku watków poziomu jadra zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom
e) Szybciej odbywa sie przelaczanie miedzy watkami poziomu jadra

Zalózmy, ze nasz program przeprowadza dzialania, które moga zmienic warunek chroniony zmienna warunku.
W jakiej kolejnosci powinny zostac wykonane ponizsze czynnosci: //odpowiedź wg Mitchela (4.4.6)
1. odblokowanie muteksu towarzyszacego zmiennej warunku.
2. zmiana warunku,
3. zablokowanie muteksu towarzyszacego zmiennej warunku,
4. sygnalizacja zmiennej warunku
a) 1,2,3,4
>>>b) 3,2,4,1
c) 2,1,4,3
d) 3,2,1,4

Która z funkcji mozemy ustawic flage O_NONBLOCK dla pliku:
>>>a) open()   
>>>b) fcntl()   
c) fopen()   
d) fstat()   

Podczas mapowania pamieci wspólnej argument prot pozwala na: 
>>>a) Zamapowanie pamieci w trybie do wykonania   
b) Zablokowanie dostepu przez inne procesy do pamieci wspólnej   
c) Podanie ID uzytkownika, który moze miec dostep do pamieci (8 najstarszych bitów)   
>>>d) Zablokowanie odczytu z zamapowanej pamieci   

(IPC - system V) Wywolanie funkcji msgctl (semctl, shmctl) ze stala IPC_SET pozwala w pewnych sytuacjach na:
a) zadna z pozostalych odpowiedzi nie jest prawdziwa   
b) zmiane identyfikatora grupy twórcy   
>>>c) zmiane identyfikatora grupy wlasciciela   
d) zmiane identyfikatora uzytkownika twórcy   
>>>e) zmiane identyfikatora uzytkownika wlasciciela   

Stworzenie soketu z PF_INET6 jako rodzina protokolu komunikacji:
>>>a) jest poprawne   
>>>b) tworzy nam lacze korzystajac z IPv6   
c) umozliwa komunikacje za pomoca IPv6 oraz IPv4   
d) tworzy lacze strumieniowe   
e) tworzy lacze lokalne   
f. tworzy lacze AppleTalk   

Funkcja mq_close: Wybierz co najmniej jedna odpowiedz
a) Jeden z jej parametrów okresla, czy ma zamknac czy usunac kolejke   
>>>b) Sluzy do zamkniecia kolejki komunikatów bez jej usuwania   
c) Nie jest funkcja systemu POSIX   
d) Sluzy do usuwania kolejki komunikatów z systemu   

Utworzylismy nowy watek funkcja pthread_create) Gdy bedziemy chcieli zakonczyc ten watek bez konczenia procesu, mozemy w funkcji tego watku wywolac instrukcje lub funkcje:
a) escape   
>>>b) pthread_exit   
>>>c) return w glównej funkcji watku   
d) exit   

(IPC - system V) Do pobrania komunikatu z kolejki sluzy funkcja:
>>>a) msgrcv   
b) getmsg   
c) msgctl   
d) msgget   

Funkcja sem_wait(sem_t *sem):
a) Zwieksza wartosc semafora   
>>>b) Zmniejsza wartosc semafora   
o) Zawiesza watek, az semafor stanie sie zerowy   
>>>d) Zawiesza watek, az semafor stanie sie niezerowy   

(IPC - system V) Podniesienie opuszczonego semafora jest mozliwe:
>>>a) przez kazdy proces majacy dostep do danego semafora   
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora   
c) jedynie przez proces, który utworzyl dany semafor funkcja semget   

Co sie stanie, jesli bedziemy chcieli zapisac przy pomocy funkcji write() do niepelnej kolejki wiecej danych, niz jest ona w stanie pomiescic ?
a) zostanie wyslany sygnal SIGPIPE   
b) zawsze udaje sie wyslac dane bez blokowania, gdyz kolejka posiada dynamicznie powiekszany bufor   
>>>c) jesli flaga O_NONBLOCK jest ustawiona, a rozmiar przesylanych danych jest wiekszy niz PIPE_BUF, funkcja zwróci 0   
>>>d) jesli flaga O_NONBLOCK nie jest ustawiona to proces zapisujacy dane w momencie wypelnienia kolejki zostaje uspiony   

Poprawna sekwencja wywolan po stronie serwera, prowadzaca do akceptacji polacznia od klienta w strumieniowym trybie komunikacji (SOCK_STREAM):
a) socket, listen, accept, bind   
b) listen, socket, bind, accept   
>>> c) socket, bind, listen, accept   
d) bind, socket, accept, listen   

Wskaz stwierdzenia prawdziwe:
>>>a) Zmienne warunków sa jednym z mechanizmów synchronizacji watków.   
>>>b) Funkcja pthread_cond_broadcast wysyla informacje o zajsciu zdarzenia do wszystkich watków oczekujacych na zajscie tego zdarzenia)   
c) Zmienne warunków sa jednym z mechanizmów synchronizacji procesów.   
d) Funkcja pthread_cond_wait nigdy nie zablokuje dzialania watku.   

Czym róznia sie watki poziomu uzytkownika od watków poziomu jadra
a) Szybciej odbywa sie przelaczanie miedzy watkami poziomu jadra   
>>>b) W przypadku watków poziomu jadra zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom   
>>>c) Szybciej odbywa sie przelaczanie miedzy watkami poziomu uzytkownika   
>>>d) Watki poziomu jadra sa obslugiwane jaka pracujace w obrebie tej samej przestrzeni adresowej procesy.   
e) W przypadku watków poziomu uzytkownika zachlanny watek nie moze zabrac czasu wykonywania pozostalym watkom   

(IPC - system V) Usuniecie segmentu pamieci wspólnej po wywolaniu funkcji shmctl ze stala IPC_RMID nastepuje:
a) zawsze natychmiast   
>>>b) dopiero gdy nie bedzie procesu, który mialby dolaczony ten segment do swojej przestrzeni adresowej   
c) natychmiast gdy jest ono realizowane przez proces z uprawnieniami nadzorcy   
d) w sytuacji gdy inne procesy korzystaja z tego segmentu natychmiast tylko gdy podamy flage SHM_NOERROR   

Które funkcje powduja calkowite usuniecie kolejki Posix z systemu?
a) int mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr) z odpowiednimi atrybutami   
>>>b) int mq_unlink(const char *name);   
c) int mq_close(mqd_t mqdes);   
d) int mq_remove(mqd_t mqdes);   
e) int mq_delete(mqd_t mqdes);   

Podajac adres do komunikacji nalezy pamietac o tym ze:
a) nie moze on byc adresem z sieci lokalnej   
b) nie mozna go uzywac wielokrotnie   
>>>c) mozna go pobrac z adresu np. www.agh.edu.pl za pomoca funkcji gethostbyname   
>>>d) mozna go pobrac z adresu w formie ip (np. 149.156.96.9) za pomoca funkcji inet_aton   
>>>e) moga wystepowac rózne sposoby zapisu danych binarnych i nalezy sie upewnic ze podawany adres jest w postaci uzywanej w sieci   

(IPC - system V) Podniesienie opuszczonego semafora jest mozliwe:
a) jedynie przez proces, który utworzyl dany semafor funkcja semget   
b) jedynie przez proces, który dokonal wczesniej opuszczenia danego semafora   
>>>c) przez kazdy proces majacy dostep do danego semafora   

Pamiec wspólna) Wskaz prawdziwe zdanie:
a) Moze z niej korzystac tylko jeden okreslony proces   
>>>b) Aby korzystac z funkcji ktore ja obsluguja nalezy zainkludowac plik sys/mman.h   
>>>c) Tworzymy ja przy pomocy funkcji shm_open(const char *name, int oflag, mode_t mode)   
d) Po wywolaniu funkcji shm_open nie musimy mapowac objektu pamieci wspolnej na przestrzen adresowa w pamieci   

(IPC - system V) Zaznacz zdania falszywe:
a) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej ale ich nie zwalnia   
b) Wykonujac polecenie ipcs z flaga -m mozna uzyskac informacje o segmentach pamieci wspóldzielonej w systemie   
>>>c) Wywolanie przez proces, który stworzyl pamiec wspóldzielona, funkcji exec lub exit odlacza segmenty pamieci wspóldzielonej od przestrzeni adresowej tego procesu oraz usuwa segmenty z systemu   
d) Uzycie jako parametru wywolania shmctl stalej IPC_STAT oraz przekazanie wskaznika do struktury shmid_ds umozliwia pobranie informacji o segmencie   

Co to jest POSIX?
a) Definuje zalecany sposób wzajemnego oddzialywania aplikacji i systemu operacyjnego   
>>>b) Standard interfejsów ulatwiajacy przenosnosc programów   
c) Funkcja systemowa   
d) System operacyjny   

Watki nalezace do tego samego procesu
a) Otrzymuja kopie wszystkich zasobów systemowych procesu nadrzednego   
>>>b) Kazdy z watków posiada wlasny niezalezny stos.   
>>>c) Zasoby systemowe procesu sa dzielone miedzy jego watki.   
d) Wspóldziela ze soba stos procesu nadrzednego.   
>>>e) Moga posiadac dane prywatne skojarzone z pewnymi kluczami dostepne tylko w watku, który dokanal takiego skojarzenia   

Chcac uzywac watków w programie trzeba dolaczyc biblioteke:
a) unixthread   
b) posixthreads   
c) nie ma mozliwosci uzywania watkow w unixie bo nie definiuje ich norma POSIX   
>>>d) pthread   

(IPC - system V) Pojedyncze wywolanie funkcji msgrcv umozliwia odczytanie z kolejki komunikatów:
>>>a) pierwszego umieszczonego w niej komunikat (kolejka FIFO)   
b) ostatnio umieszczonego w niej komunikatu, którego typ nie przekracza wartosci bezwzglednej parametru okreslonego w wywolaniu   
c) ostatnio umieszczonego w niej komunikatu (kolejka LIFO)   
d) ostatnio umieszczonego w niej komunikatu o okreslonym w wywolaniu typie   
>>>e) pierwszego komunikatu o okreslonym w wywolaniu typie   

Czy przez ponizsze deklaracje zostanie w programie wyrzucony blad?:
...
int tab[2];
...
if(pipe(tab, STDIN) < 0)
...
>>>a) tak, poniewaz w pipe drugiego argumentu nie powinno w ogóle nie byc   
b) tak, poniewaz w pipe nie powinno byc wogole pierwszego argumentu   
c) tak, poniewaz w pipe pierwszym argumentem powinno byc tab[0]   
d) tak, poniewaz tablica powinna byc typu pid_t a nie int   
e) nie

Kazdy komunikat w kolejce komunikatów POSIX zawiera:
>>>a) Rozmiar obszaru danych
>>>b) Dane komunikatu
>>>c) Priorytet komunikatu
d) Identyfikato watka, który wyslal komunikat
e) Identyfikator procesu, który wyslal komunikat

Do zwolnienia bloku pamieci wspólnej POSIX sluzy funkcja:
a) Pamiec nie moze byc zwalniana recznie) Zwalnia ja system operacyjny po zakonczeniu procesów, które sie do niej odwoluja
b) close
c) shm_delete
d) unlink
>>>e) shm_unlink
f) shm_close

3. Funkcja sem_wait(sem_t *sem):
>>>a) Zawiesza watek, az semafor stanie sie niezerowy
>>>b) Zmniejsza wartosc semafora
c) Zwieksza wartosc semafora
d) Zawiesza watek, az semafor stanie sie zerowy

4. Do obiektów IPC POSIX stworzonych przy uzyciu mq_open sem_open shm_open maja dostep (Wskaz zdania prawdziwe):
>>>a) Zalezne jest to od uprawnien nadanych obiektowi IPC
>>>b) Proces "rodzic" oraz procesy potomne
c) Zalezy od implementacji w systemie
d) Wszytkie procesy

6. Pojedyncze wywolanie funkcji msgrcv umozliwia odczytanie z kolejki komunikatów:
a) ostatnio umieszczonego w niej komunikatu o okreslonym w wywolaniu typie
>>>b) pierwszego komunikatu o okreslonym w wywolaniu typie
>>>c) pierwszego umieszczonego w niej komunikat (kolejka FIFO)
d) ostatnio umieszczonego w niej komunikatu (kolejka LIFO)
e) ostatnio umieszczonego w niej komunikatu, którego typ nie przekracza wartosci bezwzglednej parametru okreslonego w wywolaniu

7. Obsluga sygnalow w watku przedstawia sie nastepujaco :
a) dla kazdego watku nalezy wywolac procedure signal , gdyz watek nie dziedziczy ustawien sygnalów po watku glównym
>>>b) Kazdy watek moze miec odrebna maske blokowania sygnalów
>>>c) Wszystkie watki w jednym procesie wspóldziela procedury obslugi sygnalów, domyslnie ustawione przez programiste
d) W systemie Linux nie ma mozliwosci wysylania komunikatów pomiedzy watkami, adresowanych do konkretnego watku.

Utworzylismy nowy watek funkcja pthread_create Gdy bedziemy chcieli zakonczyc ten watek bez konczenia procesu, mozemy w funkcji tego watku wywolac instrukcje lub funkcje:
a) escape
b) exit
>>>c) pthread_exit
>>>d) return w glównej funkcji watku

Mutex typu PTHREAD_MUTEX_RECURSIVE_NP ma nastepujace cechy?
>>>a) Watek, który zablokowal mutex, moze zwiekszyc licznik blokad mutexu
b) Mutex zawsze odblokowujemy tylko raz
c) Zadna z pozostalych odpowiedzi nie jest prawdziwa
d) Kazdy watek moze zwiekszyc licznik blokad mutexu

Korzystanie z protokolu TCP przy gniazdach:
a) jest niemozliwe
b) jest mozliwe w dziedzinie Unixa w trybie connection-oriented (SOCK_STREAM)
c) jest mozliwe w dziedzinie Internetu w trybie connectionless (SOCK_DGRAM)
>>>d) jest mozliwe w dziedzinie Internetu w trybie connection-oriented (SOCK_STREAM)
>>>e) TCP jest domyslnym protokolem dla odpowiedniej pary dziedzina - tryb komunikacji

Kazdy program dzialajacy jako serwer musi w swoim kodzie miec wywolanie funkcji?
>>>a) bind(...)
b) connect(...)
c) listen(...)
>>>d) socket(...)
e) setsockopt(...)
f) accept(...)

13. (IPC - system V) Jaka wartosc mozna ustawic jako trzeci argument funkcji semget ?
a) SEM_NOERROR
b) SEM_UNDO
c) IPC_PRIVATE
d) IPC_NOWAIT
>>>e) IPC_CREATE

14. (IPC - system V) Zaznacz prawdziwe zdania z nastepujacych:
a) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipcls
b) do usuniecia zasobu IPC systemu V sluzy polecenie rmipc
>>>c) do usuniecia zasobu IPC systemu V sluzy polecenie ipcrm
d) do wyswietlenia listy utworzonych zasobów IPC systemu V sluzy polecenie ipc

15. (IPC - system V) Zaznacz prawdziwe zdania:
>>> a) Funkcja shmat zwraca wskaznik do segmentu pamieci wspólnej, jesli operacja zakonczyla sie sukcesem
b) Funkcja shmget tworzy segment pamieci wspólnej i dolacza go do przestrzeni adresowej procesu wywolujacego
c) Zadna z pozostalych odpowiedzi nie jest prawdziwa
>>> d) Przy uzyciu funkcji shmctl mozna miedzy innymi usunac z systemu segment pamieci wspólnej lub tez, w przypadku bycia nadzorca systemu, zaryglowac lub odryglowac segment pamieci wspólnej
e) Funkcja shmdt sluzy do dolaczenia istniejacego segmentu pamieci wspólnej do przestrzeni adresowej procesu 

MUTEXy dzielimy na:
>>> a) Szybkie
b) Wielowatkowe (moze wejsc wiecej niz jeden watek)
>>> c) Rekurencyjne
>>> d) Sprawdzajace błędy

::IPC - system V::Zaznacz prawdziwe zdania:
a) Jezeli wywolujac funkcje semop bedziemy alokowac zasoby (wartosc sem_op ujemna) i jezeli ustawimy sygnalizator SEM_UNDO, to jezeli zasób nie zostanie zwolniony w ciagu zadanego przedzialu czasu, to jadro zwolni go automatycznie
>>> b) Jezeli wywolujac funkcje semop bedziemy alokowac zasoby (wartosc sem_op ujemna) i jezeli ustawimy sygnalizator SEM_UNDO, to jadro bedzie pamietac, ile zasobów zajelismy dla danego semafora i w momencie wykonania exit przez proces jadro sprawdzi, czy istnieja nie zastosowane wartosci nastawiajace dla tego semafora i w razie potrzeby dokona wyrównania wartosci semafora
>>> c) Funkcja semop realizuje w sposób atomowy operacje na zbiorze semaforów tzn. albo zostana wykonane wszystkie zadane operacje, albo zadna
>>> d) Operacja wykonywana przez funkcje semop moze zmienic stan co najwyzej jednego semafora ze zbioru
e) Zadne z pozostalych zdan nie jest prawdziwe 

Przy tworzeniu/otwarcia obiektu pamieci wspólnej POSIX (shm_open) mozemy podac nastepujace flagi:
>>> a) O_RDONLY - pamiec tylko do odczytu
b) O_WRONLY - pamiec tylko do zapisu
>>> c) O_RDWR - pamiec do odczytu i zapisu
d) Zadne z przedstawionych. Pamiec dzielona jest zawsze do odczytu i zapisu 

Które zdanie dotyczace funkcji pthread_exit jest nieprawdziwe:
a) Konczy dzialanie watku, który ja wywolal.
>>>b) Jesli watek jest odlaczony wartosc zwracana bedzie pózniej dostepna dla funkcji pthread_join
>>>c) Ignoruje ona wszystkie procedury czyszczace i destruktory danych wlasnych
d) Przyjmuje jako parametr wartosc jaka ma zostac zwrócona przez zakonczony watek
>>>e) Jesli jako drugi parametr podamy ID watku, watek ten zostanie zakonczony  

Które funkcje powoduja calkowite usuniecie kolejki Posix z systemu?
a) int mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr) z odpowiednimi atrybutami 
>>>b) int mq_unlink(const char *name); 
c) int mq_close(mqd_t mqdes); 
d) int mq_remove(mqd_t mqdes); 
e) int mq_delete(mqd_t mqdes); 

Obsluga sygnalow w watkach (wskazac prawdziwe zdania):
a) watki nie dziedzicza obslugi sygnalu po watku zarzadcy i kazdy z nich musi na nowo wywolac funkcje signal
>>>b) kazdy watek ma osobna maske sygnalów
c) watki wspóldziela obsluge sygnalów 
